<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jei&#39;s blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://jae-kwang.github.io/blog/"/>
  <updated>2018-02-04T06:59:10.899Z</updated>
  <id>https://jae-kwang.github.io/blog/</id>
  
  <author>
    <name>Jei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>리엑트로 프로젝트 갈아입히기</title>
    <link href="https://jae-kwang.github.io/blog/2018/02/04/project-react/"/>
    <id>https://jae-kwang.github.io/blog/2018/02/04/project-react/</id>
    <published>2018-02-04T06:37:32.000Z</published>
    <updated>2018-02-04T06:59:10.899Z</updated>
    
    <content type="html"><![CDATA[<p>2018년의 첫 번째 목표는 “서비스 중인 프로젝트를 ‘리엑트’로 바꿔보자!”입니다. 이 목표를 수행하면서 진행한 여러 작업을 정리해보려 합니다.</p><a id="more"></a><h3 id="서버사이드-렌더링-프로젝트-구축하기"><a href="#서버사이드-렌더링-프로젝트-구축하기" class="headerlink" title="서버사이드 렌더링 프로젝트 구축하기"></a>서버사이드 렌더링 프로젝트 구축하기</h3><p>프로젝트는 서버사이드 렌더링이 필요했습니다. <span class="highlight-text primary">SSR(Server Side Rendering)</span>이란 말 그대로 렌더링 되어야 할 파일들이 미리 서버에서 렌더링이 되어서 내려오는 것을 의미합니다.</p><p>리엑트는 Webpack을 통해 JSX로 형태로 구성된 파일들을 컴파일해서 브라우저가 읽을 수 있는 번들 파일을 만들어 화면을 렌더링하는 <span class="highlight-text primary">CSR(Client-side Rendering) </span>방식으로 렌더링하는 방식이 보통의 방식으로 사용되고 있습니다. 그러면 어떻게 리엑트가 SSR이 되도록 할까요?</p><p></p><p>리엑트 사용 시 컴포넌트를 렌더링 하기 위해 ‘react-dom’을 import 하는데, 이때 ‘react-dom’에는 <code>renderToString</code>란 메서드가 존재합니다. 이는 리엑트 컴포넌트를 단순 문자열로 변환시켜서 서버에서 바로 사용할 수 있게 해줍니다.</p><p>서버는 Node.js express 구성되어있으며, 아래와 같이 기본 html 형태를 템플릿 리터럴 형태로 내려주었습니다. 이때 <code>renderToString</code> 에 리엑트 엘리먼트를 넘긴 형태를 root 엘리먼트의 자식으로 넘겨주는 방식으로 사용할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderToString &#125; from 'react-dom/server'</span><br><span class="line"></span><br><span class="line">res.send(`</span><br><span class="line">    <span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSR App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span>$&#123;renderToString(<span class="tag">&lt;<span class="name">App</span> <span class="attr">data</span>=<span class="string">&#123;preloadedState&#125;/</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">`)</span><br></pre></td></tr></table></figure><p>이렇게 작업한 ‘server.js’파일을 <code>node server.js</code> 가 아닌 <code>babel-node server.js</code>로 Run하여 서버를 띄웠습니다. 또한, webpack을 통해 얻은 ‘bundle.js’를 추가해 상호 작용이 가능하도록 했습니다. 여기에서 <code>preloadedState</code>는 서버에서 직접 받는 데이터로써 해당 데이터를 props로 전달해 component에서 활용합니다.</p><h3 id="리덕스-Redux-설정하기"><a href="#리덕스-Redux-설정하기" class="headerlink" title="리덕스(Redux) 설정하기"></a>리덕스(Redux) 설정하기</h3><p>이 프로젝트는 크기가 크지 않아 처음에는 리덕스를 사용하지 않으려 했습니다. 하지만 앱의 기능 중 하나로 페이지 전체의 ‘언어변경’기능이 있었는데 이는 언어 변경 시 전체 페이지의 언어가 다른 국가의 언어로 변경되어야 했습니다. 그렇다는건 모든 텍스트가 직접 컴포넌트에 작성되어 있는 게 아니라 레퍼런스 값이어야 컨트롤이 가능하다는 것을 의미했습니다. <strong>매 컴포넌트 작업 시 언어정보를 root에서 받아서 사용하는 건 매우 비효율적인 작업이 아닐 수 없었습니다.</strong></p><p>컴포넌트에서 즉시 값을 사용할 수 있게 리덕스를 적용해보았습니다. ‘redux’의 <code>createStore</code>를 사용해 서버에서 받은 값인 ‘preloadedState’와 store 를 컨트롤 하기 위한 ‘reducers’를 넘겨서 store를 생성합니다. 생성된 store를 react와 연결하는 역할을 하는 ‘react-redux’의 <code>Provider</code> 사용해 리엑트에 주입합니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderToString &#125; from 'react-dom/server'</span><br><span class="line">import &#123; createStore &#125; from 'redux'</span><br><span class="line">import &#123; Provider &#125; from 'react-redux'</span><br><span class="line">import reducers from './reducers'</span><br><span class="line"></span><br><span class="line">const store = createStore(reducers, preloadedStateㅇ)</span><br><span class="line"></span><br><span class="line">res.send(`</span><br><span class="line">    <span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSR Redux App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span>$&#123;renderToString(<span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">App</span> /&gt;</span><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.__PRELOADED_STATE__ = $&#123;<span class="built_in">JSON</span>.stringify(preloadedState)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">`)</span><br></pre></td></tr></table></figure><p>이제 컴포넌트들은 store를 통해 값을 받아 사용할 수 있습니다. 랜더링 이후에도 ‘bundle.js’에도 동일하게 store를 사용해야하기 때문에 브라우저의 전역 변수인 window에 임의값(<code>__PRELOADED_STATE__</code>)에 preloadedState를 넣어 주도록 합니다.</p><h3 id="HMR-Hot-Module-Replacement-사용하기"><a href="#HMR-Hot-Module-Replacement-사용하기" class="headerlink" title="HMR(Hot Module Replacement) 사용하기"></a>HMR(Hot Module Replacement) 사용하기</h3><span class="highlight-text primary">HMR</span>이란 코드의 수정사항 발생시 브라우저의 새고로침 없이 모듈을 업데이트 해주는 기능을 말합니다. 저는 이를 위해 <code>webpack-hot-middleware</code>를 사용하기로 했습니다. <code>webpack-hot-middleware</code>는 <code>webpack-dev-middleware</code>에 의존적이기 때문에 두가지가 설치되어야 합니다.<br><br>webpack.config.js에 entry와 plugins에 다음과 같이 추가합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry: [</span><br><span class="line">    <span class="string">'webpack-hot-middleware/client'</span>,</span><br><span class="line">    path.resolve(__dirname, <span class="string">'src'</span>)</span><br><span class="line">],</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.NoErrorsPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>server.js에 <code>webpack-dev-middleware</code>와 <code>webpack-hot-middleware</code>를 사용하도록 설정합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">var</span> webpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.config'</span>)</span><br><span class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig)</span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">"webpack-dev-middleware"</span>)(compiler, &#123;</span><br><span class="line">    noInfo: <span class="literal">true</span>,</span><br><span class="line">    publicPath: webpackConfig.output.publicPath</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">"webpack-hot-middleware"</span>)(compiler))</span><br></pre></td></tr></table></figure></p><p>store값 변경에도 hmr이 감지하도록 reducers를 바라보도록 합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">'development'</span> &amp;&amp; <span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./reducers'</span>, () =&gt; &#123;</span><br><span class="line">        store.replaceReducer(<span class="built_in">require</span>(<span class="string">'./reducers'</span>).default);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위에 보시면 <code>process.env.NODE_ENV == &#39;development&#39;</code>가 있습니다. 이는 개발 환경에서만 이를 사용한다는 의미입니다. 이렇게 분기를 준 이유는 HRM은 일종의 가상 웹서버를 띄워서 그 웹서버를 제어해 컴포넌트 변화 시 화면을 리렌더링하는 방식입니다. 하지만 서버사이드 프로젝트로 다른 서버를 통해 렌더링 되게 프로젝트를 구성한 현재의 방식에는 적합하지 않습니다. 그렇기 때문에 랜더링 되는 부분을 개발 모드와 프로덕션 모드로 나눠줍니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">if (process.env.NODE_ENV === 'development') &#123;</span><br><span class="line">    res.send(`</span><br><span class="line">        <span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSR Redux App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.__PRELOADED_STATE__ = $&#123;<span class="built_in">JSON</span>.stringify(preloadedState)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">    `)</span><br><span class="line">&#125; else if (process.env.NODE_ENV === 'production')</span><br><span class="line">    res.send(`</span><br><span class="line">        <span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSR Redux App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span>$&#123;renderToString(<span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">App</span> /&gt;</span><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.__PRELOADED_STATE__ = $&#123;<span class="built_in">JSON</span>.stringify(preloadedState)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">    `)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>개발 모드에서는 <code>renderToString</code>을 사용하는 SSR이 아닌 CSR을 이용하도록 해서 HMR이 동작하도록 합니다.  </p><blockquote><p><a href="https://blog.cloudboost.io/live-reload-hot-module-replacement-with-webpack-middleware-d0a10a86fc80" target="_blank" rel="external">Live Reload / Hot Module Replacement with Webpack Middleware</a><br><a href="http://madole.github.io/blog/2015/08/26/setting-up-webpack-dev-middleware-in-your-express-application/" target="_blank" rel="external">Setting Up Webpack Dev Middleware in Express</a></p></blockquote><h3 id="styled-component-사용하기"><a href="#styled-component-사용하기" class="headerlink" title="styled-component 사용하기"></a>styled-component 사용하기</h3><p>리엑트는 컴포넌트 방식으로 코드를 모듈화합니다. 그럼 컴포넌트란 무엇을 의미할까요? <strong>저는 html, CSS, JS가 하나로 뭉쳐있어서 그것만 다른 곳에 놓더라도 바로 사용할 수 있는 것이라고 생각합니다.</strong> 하지만 현재의 상태로는 html과 JS는 합쳐 있지만, CSS는 그렇지 않습니다. 여전히 CSS는 다른 파일에서 작업 된 후 적용이 되어야 하죠. 그렇기 때문에 <a href="https://www.styled-components.com/" target="_blank" rel="external">styled-component</a>를 사용하기로 했습니다.</p><p>기본적으로 컴포넌트에서 styled-components를 import 해서 사용 할 수 있지만, 서버사이드 렌더링 시에는 추가로 작업해줘야 할 부분이 있습니다.</p><p>‘styled-components’의 <code>ServerStyleSheet</code>를 통해 얻은 sheet 인스턴스의 collectStyles메서드로  렌더링 될 앱에 넘겨주어야 하며 sheet 인스턴스의 <code>getStyleTags()</code> 를 통해 렌더링 될 컴포넌트의 CSS를 얻어 head에 넣어줍니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderToString &#125; from 'react-dom/server'</span><br><span class="line">import &#123; createStore &#125; from 'redux'</span><br><span class="line">import &#123; Provider &#125; from 'react-redux'</span><br><span class="line">import reducers from './reducers'</span><br><span class="line">import &#123; ServerStyleSheet &#125; from 'styled-components'</span><br><span class="line"></span><br><span class="line">const store = createStore(reducers, preloadedState)</span><br><span class="line">const sheet = new ServerStyleSheet()</span><br><span class="line">const styles = sheet.getStyleTags()</span><br><span class="line">if (process.env.NODE_ENV === 'development') &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; else if (process.env.NODE_ENV === 'production')</span><br><span class="line">    res.send(`</span><br><span class="line">        <span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSR Redux styled-components App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">                $&#123;styles&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span>$&#123;renderToString(sheet.collectStyles(<span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">App</span> /&gt;</span><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.__PRELOADED_STATE__ = $&#123;<span class="built_in">JSON</span>.stringify(preloadedState)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">    `)</span><br></pre></td></tr></table></figure><h4 id="프로젝트-구성하기"><a href="#프로젝트-구성하기" class="headerlink" title="프로젝트 구성하기"></a>프로젝트 구성하기</h4><p>어느 정도 환경은 세팅이 되었다는 판단으로 관련 파일들을 어떻게 구성해야 할지 고민이 많았습니다. 대략적인 구조를 오픈소스들을 참고하며 구조를 잡아 보았습니다.</p><ol><li><b>containers, components</b><ul><li>components : 재사용 가능한 컴포넌트들을 관리합니다</li><li>containers : 프로젝트는 단일 페이지로 router 설정이 필요 없었습니다. 하지만 서버에서 IP를 판단해서 그에 따라 다른 페이지가 나와야 하므로 container는 페이지를 나누는 구분으로 사용하였습니다. (원래라면 components 하위에 존재하는 컴포넌트들을 다루는 여러 핸들러나 로직이 있는 컴포넌트를 모아두는 데 주로 사용합니다.)</li></ul></li><li><b>reducers, actions, constants, store</b><ul><li>Redux 에 종속적인 디렉터리입니다.</li><li>reducers: 액션 타입에 따라 store에 직접 접근해 store 값을 수정하는 리듀서 작업을 위치시킵니다.</li><li>actions: dispatch에 넘겨줄 액션 생성자를 정의하거나, dispatch 후 리듀서로 접근 하기 전 값을 컨트롤할 함수를 작성합니다. (이를 위해 redux-thunk 합니다.)</li><li>contants: 액션 타입을 정해놓은 상숫값들을 지정해 놓은 파일을 넣어둡니다. (actionTypes.js)</li><li>store: store 설정 파일이 있습니다. (configureStore.js)</li></ul></li><li><b>API</b><ul><li>server에 직접 API를 호출하는 역할을 합니다.</li></ul></li></ol><h4 id="데이터-플로우"><a href="#데이터-플로우" class="headerlink" title="데이터 플로우"></a>데이터 플로우</h4><ol><li>해당 프로젝트의 containers 단순 IP에 의존한 페이지 구분을 목적으로 합니다.</li><li>store에 저장될 필요 없는 stateless 한 컴포넌트의 경우 API에 직접 접근하여 기능을 수행할 수 있습니다.</li><li>store에 저장되어야 하는 값은 reducer에 action을 넘겨주는 동작을 반드시 수행해야 합니다.<ul><li>이때 서버에 데이터가 있어야 하는 경우 <code>redux-thunk</code>를 활용해서 비동기 처리를 합니다.</li></ul></li></ol><div class="figure center" style="width:;"><img class="fig-img" src="cycle.png" alt=""></div><blockquote><p>참고 :<br><a href="http://huns.me/development/1953" target="_blank" rel="external">리덕스(Redux) 애플리케이션 설계에 대한 생각</a></p></blockquote><h4 id="배포-전-닥친-새로운-문제"><a href="#배포-전-닥친-새로운-문제" class="headerlink" title="배포 전 닥친 새로운 문제"></a>배포 전 닥친 새로운 문제</h4><p>맨 처음 프로젝트를 설정할 때 <code>babel-node server.js</code>로 서버를 Run 한다는 생각으로 프로젝트를 구성하였습니다. 하지만 babel-node가 <a href="https://babeljs.io/docs/usage/cli/#babel-node" target="_blank" rel="external">‘프로덕션 모드에 사용돼서는 안 된다’</a>는 사실을 알게 되었습니다. 오픈소스 프로젝트들이 production 모드에서 babel-node를 설정한 부분을 정확히 확인하지 않고 그대로 적용한 저의 실수였습니다.</p><div class="figure center" style="width:;"><img class="fig-img" src="areyoukiddingme.gif" alt=""></div><p>오픈소스를 조사하면서 서버사이드 렌더링 시 서버를 Run 하는 방법은 크게 두 가지로 나눌 수 있었습니다.</p><ol><li>babel-node로 서버를 구동한다.</li><li>서버를 채로 번들링 한 후 node로 서버를 구동한다.</li></ol><p>1번 항목은 프로덕션 배포를 앞둔 저에게는 답이 될 수 없었습니다. 그리고 2번 항목은 저에게는 맞지 않았습니다. 해당 프로젝트는 API Server가 따로 없이 express 서버에 API가 같이 존재했으며, 해당 백엔드 작업은 제가 작업하지 않았거니와 백엔드를 잘 모르는 저에게 그 코드를 번들링해버리는 건 무책임한 행동이라고 생각이 들었습니다.</p><p><strong>그래서 저는 생각 끝에 다음과 같은 방식으로 변경을 시도했습니다.</strong></p><ol><li>서버사이드 렌더링시 템플릿 리터럴 형태로 내려주는 파일을 별도의 .html로 추출합니다.<br>이때 기존에 JS들이 들어가는 위치에 특정 형태의 string으로 추가해 놓습니다 (ex: &lt;% data %&gt;</li><li>renderToString 및 store 설정, styled-components 등 페이지 설정 부분을 별도의 .js 추출합니다.</li><li>wepack.config.prod.js에 또 하나의 번들 task를 추가해 위에서 2번에서 작업한 .js파일을 node.js에서 읽을 수 있는 <code>commonjs</code>형태로 번들링 되도록 설정합니다.</li><li>서버에서 페이지를 내려주는 종단에서 .html을 fs로 읽어들이고, 3번에서 번들링된 모듈을 호출해 각각의 값을 읽습니다.</li><li>읽은 .html을 toString().replace() 통해 치환해줍니다.</li></ol><p>결과적으로 제가 원하는 대로 server는 건드리지 않고 렌더링 되는 부분만 번들링해서 사용할 수 있게 되었습니다.</p><blockquote><p>참고 :<br><a href="http://webframeworks.kr/tutorials/react/server-side-rendering/" target="_blank" rel="external">React 애플리케이션의 서버 렌더링</a></p></blockquote><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>해당 글에는 언급되지 않았지만 이를 제외하고도 많은 문제가 있었고 해결하지 못한 문제들도 많았습니다. 솔직히 말하면 생각했던 방향대로 작업 되지 않아 굴복하고 동작하게끔만 설정해놓은 부분도 더러 있었습니다. 하지만 목표대로 서비스가 되는 프로젝트를 정상적으로 리엑트로 변경하는 작업은 성공이라고 생각됩니다. 시간이 될 때마다 작업한 프로젝트를 손보면서, 새로운 프로젝트에는 또 다른 방식 혹은 더 나은 방식으로 구성해서 작업 해봐야겠습니다. 글이 생각보다 길어져 작업 후 느낀점 같은 부분은 제 기술 블로그가 아닌 개인 블로그에 따로 정리를 해야 할 것 같습니다. 읽어주셔 감사합니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018년의 첫 번째 목표는 “서비스 중인 프로젝트를 ‘리엑트’로 바꿔보자!”입니다. 이 목표를 수행하면서 진행한 여러 작업을 정리해보려 합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/categories/js/react/"/>
    
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/tags/react/"/>
    
      <category term="SSR" scheme="https://jae-kwang.github.io/blog/tags/SSR/"/>
    
      <category term="project" scheme="https://jae-kwang.github.io/blog/tags/project/"/>
    
      <category term="styled-components" scheme="https://jae-kwang.github.io/blog/tags/styled-components/"/>
    
  </entry>
  
  <entry>
    <title>클로저(closure)란?</title>
    <link href="https://jae-kwang.github.io/blog/2017/11/13/js-closure/"/>
    <id>https://jae-kwang.github.io/blog/2017/11/13/js-closure/</id>
    <published>2017-11-13T01:02:33.000Z</published>
    <updated>2018-01-29T01:34:22.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="클로저-closure"><a href="#클로저-closure" class="headerlink" title="클로저(closure)"></a>클로저(closure)</h3><p>자바스크립트에서 빠지지 않은 개념 중 하나인 클로저에 대해 알아봅시다.</p><a id="more"></a><h3 id="아직도-클로저"><a href="#아직도-클로저" class="headerlink" title="아직도 클로저"></a>아직도 클로저</h3><p>자바스크립트를 사용한지 꽤 지났음에도 불구하고 다시 한번 클로저에 대한 포스팅을 올린다는것은 아직도 내가 클로저를 완벽하게 이해하지 못한다는 것을 의미하고 있는 것 같습니다.</p><p>누군가 나에게 클로저에 대하여 묻는다면, 똑부러지게 대답할 수 있을까요? ‘접근하려고 하는 함수의 생명주기가 종료됬지만, 내부함수가 참조 하고 있어서 그 함수에 접근할 수 있는 함수’입니다.</p><p>더 설명하라고 하면 아직 뭐라해야 할지 모르겠습니다. 다른 사람에게 설명할 수 있을 정도가 되야 아는 거라도 했던가요? 여러번 봤지만 오늘도 또 한번 공부해보려고 합니다. 같은 개념이지만 공부할때마다 이해하는 범위가 조금씩 확장되는것 같습니다. 이러한 이유로 또 한번 클로저를 공부해보려고 합니다.</p><h3 id="클로저를-알기-위한-키워드"><a href="#클로저를-알기-위한-키워드" class="headerlink" title="클로저를 알기 위한 키워드"></a>클로저를 알기 위한 키워드</h3><p>예전에는 클로저는 무엇이다라는 것에 대해서만 집중했지만, 클로저를 잘 이해하기 위해서는 몇가지 개념들을 사전에 이해해야 한다고 생각합니다.</p><p>제가 생각하는 클로저를 알기 전에 이해해야할 몇 가지 키워드들입니다.</p><ol><li>유효 범위(Scope)</li><li>어휘적 유효 범위(Lexical scope)</li><li>실행 컨텍스트(Execution Context)</li><li>유효 범위 체인(Scope Chain)</li></ol><h4 id="1-유효범위-Scope"><a href="#1-유효범위-Scope" class="headerlink" title="1. 유효범위(Scope)"></a>1. 유효범위(Scope)</h4><p>프로그래밍 언어에서 Scope는 변수와 매겨변수의 접근성 및 생존 기간을 제어하고, 이름 충돌 문제 및 메모리 관리를 해주는 중요한 개념 중 하나입니다.  </p><p>대표적으로 C언어와 같은 언어는 <code>블록 유효범위(Block Scope)</code>가 있습니다.</p><ol><li>블록(중괄호로 묶인 문장들의 집합) 내에서 정의된 모든 변수는 블록의 바깥쪽에서는 접근할 수 있다.</li><li>블록 내에서 정의된 변수는 블록의 실행이 끝나면 해제된다.</li></ol><p>그러나 자바스크립트는 <code>블록 유효범위</code>가 아닌 <code>함수 유효범위(Function Scope)</code>를 가지고 있습니다.<br>(ES6 이후로는 자바스크립트도 <code>블록 유효범위</code>도 사용가능합니다.)</p><div class="alert info"><p>함수 내에서 정의된 매개변수와 변수는 함수 외부에서는 유효하지 않지만, 내부에서 정의된 변수는 함수 내부 어느 곳에서도 접근할 수 있습니다.</p></div><h4 id="2-어휘적-유효-범위-Lexical-scope"><a href="#2-어휘적-유효-범위-Lexical-scope" class="headerlink" title="2. 어휘적 유효 범위(Lexical scope)"></a>2. 어휘적 유효 범위(Lexical scope)</h4><p>자바스크립트는 <code>Lexical scope</code> 특성을 지닙니다.<br>Lexical scope란 Scope가 함수 실행시점이 아닌 함수 정의 시점에 정해진다는 의미입니다.</p><p>아래의 예를 보도록 하겠습니다.<br>같은 함수 형태를 보이지만, 좌측은 ‘nero’를 우측은 ‘zero’를 출력합니다.</p><div class="figure " style="width:;"><img class="fig-img" src="lexical-scope.png" alt=""></div><p>좌측은 함수를 처음 선언하는 순간부터 log()의 name 변수는 자신의 상위 스코프의 변수 name을 참조합니다.<br>그래서 Wrapper()에서 log()를 실행하기전에 참조변수인 name을 변경했기에 ‘nero’를 출력하고 있습니다.</p><p>그러나 우측에서는 Wrapper()안에서 새로운 name 변수를 정의 하였습니다.<br>하지만 log()는 이미 상위 스코의 변수인 name을 참조하고 있기때문에 ‘zero’를 출력하게 되는 것입니다.</p><div class="alert info"><p>다시 한번 말하자면 함수가 실행될 때가 아니라 정의될 때에 변수를 참조하게 됩니다.</p></div><h4 id="3-실행-컨텍스트-Execution-Context"><a href="#3-실행-컨텍스트-Execution-Context" class="headerlink" title="3. 실행 컨텍스트(Execution Context)"></a>3. 실행 컨텍스트(Execution Context)</h4><p><code>Execution Context</code>는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념으로, 코드가 실행되는 <code>환경</code>입니다. 변수나 함수의 실행 컨텍스트는 다른 데이터에 접근할 수 있는지, 어떻게 행동하는지를 규정합니다.</p><p>자바스크립트 인터프리터가 어떤 함수를 실행시킬때마다 그 함수에 대한 새로운 실행 컨텍스트가 생성됩니다.</p><p>실행 컨텍스트가 생성되면 자바스크립트 엔진은 실행에 필요한 여러 정보들을 담을 객체를 생성합니다.<br>이를 <code>변수 객체(Variable Object)</code>라고 합니다. 해당 컨텍스트에서 정의된 모든 변수와 함수는 이 객체에 존재합니다.</p><p>실행 컨텍스트는 포함된 코드가 모두 실행된 후에 파괴되는데, 이때 해당 컨텍스트 내부에서 정의된 변수와 함수도 함께 파괴됩니다.</p><div class="alert info"><p><strong>Scope VS Context</strong><br>Scope는 변수의 가시성과 관련이 있으며, Context는 함수가 실행되는 객체를 나타냅니다.</p></div><h4 id="4-유효-범위-체인-Scope-Chain"><a href="#4-유효-범위-체인-Scope-Chain" class="headerlink" title="4. 유효 범위 체인(Scope Chain)"></a>4. 유효 범위 체인(Scope Chain)</h4><p><code>Scope Chain</code>은 일종의 리스트로서 중첩된 함수의 Scope의 참조를 차례로 저장하고 있는 개념입니다. Scope Chain의 목적은 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 순서를 정의하는 것입니다.</p><p>컨텍스트가 함수인 경우 ‘활성화 객체(activation object)’를 변수 객체(Variable Object)로 사용합니다.</p><p>중첩된 함수에서 변수 객체가 값을 찾지 못햇을 경우 해당 부모 컨텍스트에서 찾고 다시 그 다음 부모의 컨텍스에서 찾으며, 전역 컨텍스트에 도달할 때 까지 계속합니다. 전역 컨텍스트의 변수 객체는 항상 스코프 체인의 마지막에 존재합니다.</p><p>내부 컨텍스트는 스코프 체인을 통해 외부 컨텍스트 전체에 접근할 수 있지만 외부 컨텍스트는 내부 컨텍스트에 대해 전혀 알 수 없습니다. 컨텍스트 사이의 연결은 선형이며 순서가 중요합니다.  각 건텍스트는 스코프 체인을 따라 상위 컨텍스트에서 변수나 함수를 검색할 수 있지만 스코프 체인을 따라 내려가며 검색할 수는 없습니다.</p><h3 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h3><p>클로저는 가장 맨 앞에서 언급했듯 한마디로 <span class="highlight-text primary">'접근하려고 하는 함수의 생명주기가 종료됬지만, 내부함수가 참조 하고 있어서 그 함수에 접근할 수 있는 함수'</span>라고 말할 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'Hello'</span>;</span><br><span class="line">  <span class="keyword">var</span> funB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(x); &#125;;</span><br><span class="line">  <span class="keyword">return</span> funB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funC = funA();</span><br><span class="line">funC(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>funA()가 실행종료 되었으니 x또한 접근할수가 없어야 하는데 return 된 funB()를 받은 funcC()를 실행하니 x를 참조 할 수 있게 되었습니다.</p><h3 id="클로저-사용시-주의해야할-점"><a href="#클로저-사용시-주의해야할-점" class="headerlink" title="클로저 사용시 주의해야할 점"></a>클로저 사용시 주의해야할 점</h3><p>클로저는 외부 함수의 변수를 참조 합니다. 하지만 값의 복사값은 아닙니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add_the_handlers = <span class="function"><span class="keyword">function</span>(<span class="params">nodes</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;nodes.length; i++) &#123;</span><br><span class="line">nodes[i].onClick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">alert(i);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이 함수는 노드를 클릭하면 해당 노드가 몇 번째 노드인지를 경고창으로 알려주는것이 함수의 목적이지만, 함수 전체 노드의 수만 보여주게 됩니다. 이유는 함수의 i가 함수가 만들어지는 시점의 i가 아니라 그냥 상위 스코프의 변수 i를 참조하기 때문입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add_the_handlers = <span class="function"><span class="keyword">function</span>(<span class="params">nodes</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;nodes.length; i++) &#123;</span><br><span class="line">nodes[i].onClick = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">alert(i);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이제 onclick에 함수를 연결되어 있는 내부 함수에서 새로 함수를 정의하고 여기에 i를 넘기면서 곧바로 실행시켰습니다. 실행된 함수는 add_the_handlers에 정의된 i가 아니라 넘겨받은 i의 값을 이벤트 핸들러 함수에 연결하여 반환합니다.<br>이 반환되는 이벤트 핸들러 함수는 onclick에 할당합니다. 함수가 원한는 목적대로 구현이 되었습니다.</p><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>보통 코드를 잘때면 클로저를 생각하지 않고 자연스러운 흐름에 의해 클로저를 사용하는 경우가 많습니다. 앞으로는 그러한 부분에 있어서 좀더 의식적으로 이해하고 코드를 작성하도록 해야 하겠습니다. </p><blockquote><p>참고 :</p><ul><li>블로그<br><a href="http://meetup.toast.com/posts/86" target="_blank" rel="external">자바스크립트의 스코프와 클로저</a><br><a href="https://www.zerocho.com/category/Javascript/post/5740531574288ebc5f2ba97e" target="_blank" rel="external">함수의 범위(scope)</a><br><a href="http://www.nextree.co.kr/p7363/" target="_blank" rel="external">JavaScript : Scope 이해</a><br><a href="http://webclub.tistory.com/113" target="_blank" rel="external">유효범위의 효용</a><br><a href="http://poiemaweb.com/js-execution-context" target="_blank" rel="external">실행 컨텍스트와 자바스크립트의 동작 원리</a><br><a href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/" target="_blank" rel="external">Understanding Scope and Context in JavaScript</a><br><a href="https://blog.kevinchisholm.com/javascript/difference-between-scope-and-context/" target="_blank" rel="external">What is the Difference Between Scope and Context in JavaScript?</a><br><a href="https://blog.outsider.ne.kr/506" target="_blank" rel="external">자바스크립트 클로저(Closure)에 대해서…</a></li><li>책<br>자바스크립트 완벽 가이드<br>프론트엔드 개발자를 위한 자바스크립트 프로그래밍<br>함수형 자바스크립트</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;클로저-closure&quot;&gt;&lt;a href=&quot;#클로저-closure&quot; class=&quot;headerlink&quot; title=&quot;클로저(closure)&quot;&gt;&lt;/a&gt;클로저(closure)&lt;/h3&gt;&lt;p&gt;자바스크립트에서 빠지지 않은 개념 중 하나인 클로저에 대해 알아봅시다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="core" scheme="https://jae-kwang.github.io/blog/categories/js/core/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="closure" scheme="https://jae-kwang.github.io/blog/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>form 전송과 ajax 전송</title>
    <link href="https://jae-kwang.github.io/blog/2017/10/16/form-vs-ajax/"/>
    <id>https://jae-kwang.github.io/blog/2017/10/16/form-vs-ajax/</id>
    <published>2017-10-16T00:39:10.000Z</published>
    <updated>2017-10-16T00:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="form-전송과-ajax-전송의-차이"><a href="#form-전송과-ajax-전송의-차이" class="headerlink" title="form 전송과 ajax 전송의 차이"></a>form 전송과 ajax 전송의 차이</h3><p>요즘 흔히 서버와의 통신시 ajax를 사용하고 있습니다.<br>하지만 <code>&lt;form&gt;</code>을 통해서도 서버와의 통신이 가능한데 어떤 차이점이 있을까요?</p><a id="more"></a><h2 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h2><p>form 방식과 ajax 방식의 대표적인 차이점이라고 하면 역시 ajax는 페이지의 전환 없이 <code>비동기</code>로 서버와 통신을 할 수 있게 되었다는 점입니다. 이러한 <code>비동기</code>를 통해 전체 페이지가 아닌 일부분만을 업데이트 할 수 있게 해줍니다.</p><h2 id="이벤트"><a href="#이벤트" class="headerlink" title="이벤트"></a>이벤트</h2><p>사용자 인터렉션에 의헤 데이터를 서버로 전송하는경우 반드시 이벤트에 의해 발생되게 됩니다.</p><p>이때, ajax를 사용해 통신을 할 경우 이벤트를 처리하는 이벤트 리스너를 별도로 생성해야합니다.</p><p>하지만 form을 이용한다면 별도의 코드 없이 HTML에서 만으로 submit 이벤트를 발생시켜서 데이터를 서버에 전송할 수 있습니다.</p><p>form에 form submit이 가능한 버튼이 있고, form에 포커스가 있는 상태라면 <code>enter</code>를 누르면 form submit이 됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 폼 전송이 가능한 버튼 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 범용 전송 버튼 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit Form"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 커스텀 전송 버튼 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 이미지 버튼-&gt;</span></span><br><span class="line"><span class="comment">&lt;input type="image" src="graphic.gif"&gt;</span></span><br></pre></td></tr></table></figure><p>form에는 이처럼 편의 기능이 있어서, 두가지 경우를 합쳐서 사용한는 경우가 많습니다. </p><p>form을 이용해 submit 이벤트를 발생시키고, 이후에 form 전송이 막고 ajax를 통해 <code>비동기</code> 로 통신을 하는 방식이 많이 사용 되고 있습니다.</p><h2 id="content-type"><a href="#content-type" class="headerlink" title="content-type"></a>content-type</h2><p>content-type은 request로 보내는 데이터가 무엇인지 알려줍니다.</p><p>기본적으로 form과 ajax의 content-type은 <code>application/x-www-form-urlencoded</code>으로 key=value&amp;key=value 형태로 전송됩니다.</p><p>form에서는 기본 전송인 <code>application/x-www-form-urlencoded</code>방식과 파일전송 방식인 <code>multipart/form-data</code>을 사용하고 있습니다.</p><p>하지만 ajax는 기본을 제외하고 다른 라이브러리들은 이를 <code>application/json</code>과 같은 다른 방식으로 사용하는 경우가 많으니 인지하고 사용해야 합니다.</p><p>변경된 이유는 예전과 다르게 <code>다계층</code>의 데이터를 주고 받아야 할 일이 많아졌기 때문입니다.</p><blockquote><p>참고 :</p><ul><li><a href="https://gist.github.com/jays1204/703297eb0da1facdc454" target="_blank" rel="external">https://gist.github.com/jays1204/703297eb0da1facdc454</a></li><li><a href="http://fetobe.co.kr/http-protocol/" target="_blank" rel="external">http://fetobe.co.kr/http-protocol/</a></li><li><a href="http://1ambda.github.io/content-type-vs-accept-http-header/" target="_blank" rel="external">http://1ambda.github.io/content-type-vs-accept-http-header/</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;form-전송과-ajax-전송의-차이&quot;&gt;&lt;a href=&quot;#form-전송과-ajax-전송의-차이&quot; class=&quot;headerlink&quot; title=&quot;form 전송과 ajax 전송의 차이&quot;&gt;&lt;/a&gt;form 전송과 ajax 전송의 차이&lt;/h3&gt;&lt;p&gt;요즘 흔히 서버와의 통신시 ajax를 사용하고 있습니다.&lt;br&gt;하지만 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;을 통해서도 서버와의 통신이 가능한데 어떤 차이점이 있을까요?&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/tags/js/"/>
    
      <category term="form" scheme="https://jae-kwang.github.io/blog/tags/form/"/>
    
      <category term="ajax" scheme="https://jae-kwang.github.io/blog/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap의 tap plugins 분석</title>
    <link href="https://jae-kwang.github.io/blog/2017/10/11/bootstrap-tab/"/>
    <id>https://jae-kwang.github.io/blog/2017/10/11/bootstrap-tab/</id>
    <published>2017-10-11T00:10:00.000Z</published>
    <updated>2017-10-11T00:29:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Bootstrap의-tabs-코드-분석"><a href="#Bootstrap의-tabs-코드-분석" class="headerlink" title="Bootstrap의 tabs 코드 분석"></a>Bootstrap의 tabs 코드 분석</h3><p>Bootstrap은 plugin을 생성할때 코드를 어떻게 구조화하는지 tab plugin을 통해 분석해보며 이해해 봅니다.</p><p>버전은 v3.3.2을 사용합니다.</p><a id="more"></a><h3 id="코드-분석의-목적"><a href="#코드-분석의-목적" class="headerlink" title="코드 분석의 목적"></a>코드 분석의 목적</h3><p>현재 export, import 혹은 require와 같은 방법을 통해 module이나 component를 효율적으로 나눠서 사용하고 있습니다.</p><p>그렇다면 위의 기능들이 없었을때는 어떻게 효율적으로 코드를 분할할 수 있었을까요?</p><p>만약 코드 구조가 현재 지원하고 있는 방식이 아니라 다른방식일 경우 어떻게 사용할 수 있을지 알기 위함입니다.</p><h3 id="Bootstrap의-함수"><a href="#Bootstrap의-함수" class="headerlink" title="Bootstrap의 함수"></a>Bootstrap의 함수</h3><p>기본적으로 Bootstrap은 plugin을 구현시 <code>생성자 패턴</code>과 <code>프로토타입 패턴</code>을 적용해서 구현하고 있습니다.</p><p>패턴 적용시 자신만의 인스턴스를 가지면서도 참조 방식을 통해 메서드를 공유해 메모리를 절약할 수 있습니다.</p><p>Bootstrap은 다음과 같이 익명함수로 모든 기능을 정의해서 스코프가 섞이지 않도록 합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;(jQuery);</span><br></pre></td></tr></table></figure><p>여기서 <code>+</code> 다음에 나오는 부분을 파서는 표현식으로 처리하며, 위와 같이 즉시 실행함수에서 사용됩니다.</p><p>만약, <code>+</code>가 없는 상태라면 파서가 <code>function</code>을 함수 표현식이 아닌 선언식으로 인식하여 뒤에 나오는 <code>()</code>가 오류로 처리됩니다.</p><blockquote><p>참고 : <a href="https://stackoverflow.com/questions/13341698/javascript-plus-sign-in-front-of-function-name/13341710" target="_blank" rel="external">https://stackoverflow.com/questions/13341698/javascript-plus-sign-in-front-of-function-name/13341710</a></p></blockquote><h3 id="이벤트-바인딩"><a href="#이벤트-바인딩" class="headerlink" title="이벤트 바인딩"></a>이벤트 바인딩</h3><p>jQuery의 ‘on’을 API 통해 이벤트를 등록하고 있습니다.</p><p>여기서 ‘이벤트 위임(Event Delegation)’ 방식으로 이벤트를 등록하고 있습니다. </p><div class="alert info"><p><strong>이벤트 위임(Event Delegation)</strong><br>이벤트 위임은 이벤트 버블링의 장점을 활용하여, 이벤트 헨들러를 하나만 할당해서 해당 타입의 이벤트를 모두 처리하는 테크닉입니다. DOM요소 하나에만 접근해 거기에만 이벤트 핸들러를 할당하므로 비용이 훨씬 적으며, 메모리를 훨씬 조금 사용합니다.</p></div><p>이벤트 위임의 또 하나의 장점은 동적으로 생성되는 요소에 일일이 이벤트를 할당할 필요가 없다는 점입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>)</span><br><span class="line">  .on(<span class="string">'click.bs.tab.data-api'</span>, <span class="string">'[data-toggle="tab"]'</span>, clickHandler)</span><br><span class="line">  .on(<span class="string">'click.bs.tab.data-api'</span>, <span class="string">'[data-toggle="pill"]'</span>, clickHandler)</span><br></pre></td></tr></table></figure><p>이벤트 대상은 ‘[data-toggle=”tab”]’와 ‘[data-toggle=”pill”]’이며, 이벤트 처리는 ‘clickHandler’에서 진행됩니다.</p><p>이때 걸려 있는 이벤트는 ‘click’ 이벤트로, 이 이벤트는 ‘bs, tab, data-api’라는 namespace를 갖습니다.</p><h3 id="이벤트-핸들러"><a href="#이벤트-핸들러" class="headerlink" title="이벤트 핸들러"></a>이벤트 핸들러</h3><p>이벤트에 대한 이벤트 처리가 이루어집니다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  Plugin.call($(<span class="keyword">this</span>), <span class="string">'show'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엘리먼트의 e.preventDefault()를 통해 기본기능을 막고, 선언된 Tab Plugin을 .call()로 ‘show’를 호출하며 현재 ‘this’를 교체합니다.</p><h3 id="탭-플러그인-정의"><a href="#탭-플러그인-정의" class="headerlink" title="탭 플러그인 정의"></a>탭 플러그인 정의</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">var</span> data  = $<span class="keyword">this</span>.data(<span class="string">'bs.tab'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data) $<span class="keyword">this</span>.data(<span class="string">'bs.tab'</span>, (data = <span class="keyword">new</span> Tab(<span class="keyword">this</span>)))</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> option == <span class="string">'string'</span>) data[option]()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우선, 대상되는 요소의 data정보에 ‘bs.tab’이 있는지 확인하는 작업을 하는데 이는 이전에 이벤트가 바인딩 되어 있는지 체크하는 작업입니다.</p><p>만약 이벤트가 바인딩이 되어 있지 않다면 선언된 Tab을 new 통해 인스턴스를 생성하여 해당 요소의 data에 ‘bs.tab’의 값으로서 할당합니다.</p><p><strong>이 작업은 이벤트가 바인딩 되어있는지를 확인하는 flag로써 활용할 수 있으며, 실제로 기능을 하는 함수로 사용됩니다.</strong></p><p>마지막으로 option으로 넘어온 ‘show’를 실행시킵니다. (data.show())</p><h3 id="jQuery-Plugin-설정"><a href="#jQuery-Plugin-설정" class="headerlink" title="jQuery Plugin 설정"></a>jQuery Plugin 설정</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> old = $.fn.tab</span><br><span class="line"></span><br><span class="line">$.fn.tab             = Plugin</span><br><span class="line">$.fn.tab.Constructor = Tab</span><br><span class="line"></span><br><span class="line">$.fn.tab.noConflict = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.fn.tab = old</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jQuery의 Plugin을 설정시 $.fn에 연결합니다. jQuery에서는 이부분에 연결된 기능을 prototype으로 연결시킵니다.</p><p>다음으로는 Constructor에 연결합니다. 그 이유는 일부 동일한 다른 함수의 경우 (popover의 경우에는 tooptip을 상속받아서 사용)에는 다른 기능을 상속받아 사용하기 때문에 어떤 유형인지 확인이 어렵습니다. 그래서 Constructor를 사용해 어떤 유형인지 확인하는데 사용될 수 있습니다.</p><blockquote><p>참고 : <a href="https://stackoverflow.com/questions/19680895/bootstrap-constructor" target="_blank" rel="external">https://stackoverflow.com/questions/19680895/bootstrap-constructor</a></p></blockquote><p>$.fn.tab.noConflict를 사용해 이전에 $.fn.tab에 사용되고 있었던 플러그인을 사용할 수 있습니다. (예전에 동일한 이름으로 플러그인을 사용하고 있다는 가정하에)</p><h3 id="탭-클래스-정의"><a href="#탭-클래스-정의" class="headerlink" title="탭 클래스 정의"></a>탭 클래스 정의</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tab = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.element = $(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tab.VERSION = <span class="string">'3.3.2'</span></span><br><span class="line"></span><br><span class="line">Tab.TRANSITION_DURATION = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">Tab.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">Tab.prototype.activate = <span class="function"><span class="keyword">function</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>부트스랩은 프로토타입 상속에 의해 기능들이 정의 되어 있습니다.</p><p>인스턴스를 생성하기위한 Tab 클래스를 생성하고, 필요한 상수를 선언하며, 기능들을 prototype에 추가합니다.</p><p>앞서 설명된 플러그인에서 탭 플러그인 설정에서 사용되는 클래스 입니다.</p><p>Tab.prototype.show에서는 요소를 노출하기 위한 action을 trigger하는 기능들을 모아놓았으며,</p><p>Tab.prototype.activate에서는 실제 요소를 활성화 시키는 .active 클래스를 컨트롤 합니다.</p><h3 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h3><p><strong>“높은 응집도 낮은 결합도”</strong>에 대한 이해가 조금이나마 와닿은것 같습니다.<br>예전에는 머리로 이했었던 느낌이지만 요즘은 이런게 필요하구나 라는 것을 직접 느끼고 있는것 같습니다.</p><p>사실 디자인 패턴을 공부하면서 직접 적용해서 작업하는건 쉽지 않는다고 판단이 들어서,<br>유명한 라이브러리들을 조금씩 열어보면서 이들은 어떤식으로 구조화를 했었고, 어떻게 진화하고 있는지 알아보려고 했습니다.</p><p>우선 제가 가장 많이 쓰고 있는 것중에 하나인 bootstrap중에서 가장 짧은 tab을 살펴 보았습니다.<br>더 공부해야겠지만, 이러한 방식을 더 잘 이해하면 현재 사용되는 모듈 방식을 좀 더 잘 사용할 수 있지 않을까 생각됩니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Bootstrap의-tabs-코드-분석&quot;&gt;&lt;a href=&quot;#Bootstrap의-tabs-코드-분석&quot; class=&quot;headerlink&quot; title=&quot;Bootstrap의 tabs 코드 분석&quot;&gt;&lt;/a&gt;Bootstrap의 tabs 코드 분석&lt;/h3&gt;&lt;p&gt;Bootstrap은 plugin을 생성할때 코드를 어떻게 구조화하는지 tab plugin을 통해 분석해보며 이해해 봅니다.&lt;/p&gt;
&lt;p&gt;버전은 v3.3.2을 사용합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="bootstrap" scheme="https://jae-kwang.github.io/blog/categories/js/lib/bootstrap/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="bootstrap.js" scheme="https://jae-kwang.github.io/blog/tags/bootstrap-js/"/>
    
  </entry>
  
  <entry>
    <title>Under-the-hood-ReactJS(2) - 업데이트</title>
    <link href="https://jae-kwang.github.io/blog/2017/09/28/Under-the-hood-ReactJS-2/"/>
    <id>https://jae-kwang.github.io/blog/2017/09/28/Under-the-hood-ReactJS-2/</id>
    <published>2017-09-28T00:18:00.000Z</published>
    <updated>2017-10-11T00:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Under-the-hood-ReactJS의 파트 8~10인 업데이트 관련 부분입니다.</p><a id="more"></a><h3 id="파트-8"><a href="#파트-8" class="headerlink" title="파트 8"></a>파트 8</h3><h4 id="this-setState"><a href="#this-setState" class="headerlink" title="this.setState"></a>this.setState</h4><div class="alert info"><p>인트로에서도 언급되었듯 업데이트의 시작은 <strong>this.setState</strong>에서 부터 다뤄집니다.</p></div><ul><li>setState는 <code>ReactComponent</code>에서 컴포넌트를 상속받았고, <code>updater</code> 속성을 받습니다. (파트3)</li><li>각 컴포넌트는 자신의 pandding state의 목록을 가지고 있고, 하나의 트랜잭션에서 setState를 호출 할 때마다 그 객체를 대기열에 넣은 다음 나중에 하나씩 컴포넌트 state로 머지합니다.</li><li>setState를 호출하여, 컴포넌트를 dirtyComponents 리스트에 추가 할 수 있습니다.<ul><li>dirtyComponents는 변경된 항목들을 비교하기위해 넣어두는 리스트 입니다. (파트 10)</li></ul></li></ul><hr><h3 id="파트-9"><a href="#파트-9" class="headerlink" title="파트 9"></a>파트 9</h3><h4 id="setState-메소드가-호출되는-두가지-경우"><a href="#setState-메소드가-호출되는-두가지-경우" class="headerlink" title="setState 메소드가 호출되는 두가지 경우"></a>setState 메소드가 호출되는 두가지 경우</h4><ul><li>마우스 이벤트에 의한 호출<ul><li>마우스 이벤트가 발생하면 앞서 살펴본 것처럼 여러 레이어를 통해 일괄(batched)업데이트 되는데, ReactReconcileTransaction 래퍼가 비활성화되고 이후 ReactEventListener enabled때 다시 발생될때 안전하게 마운팅됩니다. (파트 2)</li></ul></li><li>setTimeout에 의한 호출<ul><li>setTimeout의 경우에도 위의 경우와 다르지 않게 트랜잭션이 아직 오픈되지 않았을 경우 일괄(batching) 트렌젝션 열고 dirtyComponents리스트에 영향받은 컴포넌트 추가하고 트렌젝션을 close(ReactUpdates.flushBatchedUpdates)하고 dirtyComponents를 처리합니다.</li></ul></li></ul><hr><h3 id="파트-10"><a href="#파트-10" class="headerlink" title="파트 10"></a>파트 10</h3><h4 id="Dirty-components"><a href="#Dirty-components" class="headerlink" title="Dirty components"></a>Dirty components</h4><ul><li>dirtyComponents리스트를 처리하기 위해 루프를 수행합니다.</li><li>이때 ReactUpdates.runBatchedUpdates 호출합니다.<ul><li>새로운 또 하나의 트렌젝션 <strong>ReactUpdatesFlushTransaction 래퍼</strong> 사용</li><li>dirtyComponentsLength가 변경된 경우 flushBatchedUpdates를 통해 한번 더 수행</li></ul></li><li>ReactUpdatesFlushTransaction 래퍼(dirtyComponents 배열을 지우고, 마운트 준비 핸들러(예: componentDidUpdate)가 대기열에 추가 한 모든 업데이트를 수행)<ul><li>dirtyComponets배열 정렬(mount order)</li><li>dirtyComponentsLength을 기준으로 반복해서 수행.</li><li>각 컴포넌트를 ReactReconciler.performUpdateIfNecessary로 전달.<ul><li>실제로 performUpdateIfNecessary메소드는 ReactCompositeComponent.updateComponent에서 호출합니다.</li></ul></li></ul></li></ul><hr><h3 id="파트-11"><a href="#파트-11" class="headerlink" title="파트 11"></a>파트 11</h3><h4 id="Update-component"><a href="#Update-component" class="headerlink" title="Update component"></a>Update component</h4><ul><li>setState가 호출되거나 props가 변경된 경우 updateComponent 메소드가 호출될 수 있습니다.</li><li>pending state queue기반으로 nextState를 비교합니다. (예제 에서의 {message : “click state message”})</li><li>shouldUpdate를 디폴트값 true로 설정<ul><li>실제로 <code>shouldComponentUpdate</code>가 지정되지 않은 경우에도 컴포넌트가 기본적으로 업데이트되는 이유</li></ul></li><li>강제 업데이트인지 확인<ul><li>강제 업데이트가 아닌경우 <code>shouldComponentUpdate</code> 메소드가 호출되어 <code>shouldUpdate</code>의 결과 값으로 재할당됩니다.</li></ul></li></ul><hr><h3 id="파트-12"><a href="#파트-12" class="headerlink" title="파트 12"></a>파트 12</h3><h4 id="실제로-컴포넌트를-업데이트하는-경우"><a href="#실제로-컴포넌트를-업데이트하는-경우" class="headerlink" title="실제로 컴포넌트를 업데이트하는 경우"></a>실제로 컴포넌트를 업데이트하는 경우</h4><ul><li><p><code>componentWillUpdate</code>가 명시되어 있다면 그것을 호출합니다.</p></li><li><p>컴포넌트를 리랜더링합니다.</p><ul><li>컴포넌트의 render 메소드를 호출하고, 그에 따라 DOM을 업데이트 합니다.</li><li>이전에 렌더링된 엘리먼트와 비교하여 DOM을 실제로 업데이트해 하는지 확인합니다.(update or replace completely)<ul><li>shouldUpdateReactComponent(중복된 DOM 업데이트를 피하고 리엑트 성능을 향상)</li></ul></li></ul></li><li><p><code>componentDidUpdate</code> 호출을 대기열에 추가합니다.</p></li></ul><hr><h3 id="파트-13"><a href="#파트-13" class="headerlink" title="파트 13"></a>파트 13</h3><h4 id="Receive-component"><a href="#Receive-component" class="headerlink" title="Receive component"></a>Receive component</h4><ul><li><p>shouldUpdateReactComponent -&gt; ReactReconciler.receiveComponent -&gt; ReactDOMComponent.receiveComponent</p><ul><li>위와 같은 형태로 다음 엘리먼트 전달합니다.</li></ul></li><li><p>DOM 컴포넌트 인스턴스에 전달받은 엘리먼트를 할당하고 update 메소드를 호출합니다.</p></li><li><p>updateComponent 메소드는 실제로 prev와 next props를 기반으로 2가지 동작을 수행합니다.</p><ul><li>DOM properties 업데이트 : _updateDOMProperties(파트 5)</li><li>DOM children 업데이트 : _updateDOMChildren(파트 14)</li></ul></li></ul><hr><h3 id="파트-14"><a href="#파트-14" class="headerlink" title="파트 14"></a>파트 14</h3><h4 id="updateDOMChildren"><a href="#updateDOMChildren" class="headerlink" title="_updateDOMChildren"></a>_updateDOMChildren</h4><ul><li><p>‘ExampleApplication’는 button, ChildCmp, text string를 자식으로 가지고 있습니다.</p></li><li><p>해당 컴포넌트의 자식이 ‘content’형태인지 ‘complex’형태 인지 판단합니다.</p><ul><li>complex : 리엑트 컴포넌트</li><li>content : 문자열이나 숫자와 같은 단순타입</li></ul></li><li><p>complex인 경우</p><ul><li>부모 컴포넌트는 이전에 수행했던 시나리오와 동일한 시나리오를 통해 자식들을 전달합니다.</li><li>‘content’ 레벨에 도달할때까지 여러번 작업을 반복합니다.</li></ul></li><li><p>content인 경우</p><ul><li>이전과 현재 텍스트가 같은지 비교하고 수정되었다면 업데이트 합니다.(replace)</li><li>텍스트 업데이트인 경우 setTextContent를 호출해 HTML노드의 내용을 수정합니다.</li><li>콘텐츠가 업데이트되고 페이지에서 사용자를 위해 리렌더링됩니다.</li></ul></li><li><p>이전에 대기열에 넣어두었던 <code>componentDidUpdate</code>를 호출합니다. (파트 12)</p><ul><li><code>componentDidUpdate</code>를 호출할 수 있는 이유<ul><li>dirty 컴포넌트 업데이트는 ReactUpdatesFlushTransaction로 래핑되었고, 래퍼 중 하나는 실제로 this.callbackQueue.notifyAll() 로직을 포함하므로 <code>componentDidUpdate</code>를 호출되는 것입니다. (파트 10)</li></ul></li></ul></li></ul><hr><p>저는 이 글들을 번역하고 공부하면서도 실제로 100% 이해했다고는 말할 수 없었습니다. 다만 제가 리엑트 이해도를 100%로 정했을때 스스로의 이해도가 10%정도의 수준이라면 15%정도 되지 않았을까라는 생각정도만 가지고 있습니다.</p><p>그 이유로는, 저는 무언가를 읽고 학습할때 글보다는 코드로 이해하는게 훨씬 이해도가 높습니다. 그래서 제가 처음보는 말들보다는 익숙한 예약어들이 많이 등장할때 훨씬 이해가 잘되는 느낌이었습니다.</p><p>그 예약어로는 라이프사이클 메소드를 들 수가 있었고, 제가 가지고 있는 라이프사이클 순서 사이사이에 위에서 알아본 일련의 과정들을 집어넣어보면서 이해했던것 같습니다.</p><p>제법 오랜시간동안 이거 한다고 다른걸 안하고 있었으니, 이제는 실제로 써먹을 수 있을지 간단히 리엑트 프로젝트를 한번 해봐야겠습니다!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Under-the-hood-ReactJS의 파트 8~10인 업데이트 관련 부분입니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/categories/js/lib/react/"/>
    
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/tags/react/"/>
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Under-the-hood-ReactJS(1) - 마운트</title>
    <link href="https://jae-kwang.github.io/blog/2017/09/28/Under-the-hood-ReactJS-1/"/>
    <id>https://jae-kwang.github.io/blog/2017/09/28/Under-the-hood-ReactJS-1/</id>
    <published>2017-09-28T00:18:00.000Z</published>
    <updated>2017-10-11T00:30:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Under-the-hood-ReactJS를 읽어보면서 이해한 부분을 정리해보았습니다.<br>Intro ~ 파트7까지의 마운트 부분에 대한 설명이 있습니다.</p><a id="more"></a><p>처음 뭔가를 배울때는 아무것도 모르는 상태에서 책이나 다른 문서의 예제를 약간씩 따라 치면서 익히곤 합니다.</p><p>그러다 스스로 뭔가 대충 “아, 정확히는 모르겠지만 이건 요런 방식이구나…” 라고 생각되는 시점이 오면 “그런데 이게 어떻게 되는거지?”라고 생각하게 되는 것 같은데 이때 <a href="https://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/" target="_blank" rel="external">Under-the-hood-ReactJS</a>를 알게되었습니다.</p><p>영어실력이 좋지 않아서 번역기의 도움을 받으면서 몇 번씩 읽어보았고 제가 이해한 방식으로 해석하는 작업을 몇 차례 반복했습니다. 한달정도의 시간동안 틈틈히 공부 했지만, 그럼에도 이해 안된 부분들이 조금씩은 있어서, 번역된 내용중에 ‘한글인데 뭔말인지 모르겠다…’ 란 부분은 바로 그러한 부분이니 참고 부탁드립니다. :)</p><p>현재 저는 올초부터 리엑트를 공부하기 시작했지만, 실제 총 시간으로 따지만 약 두달 정도만 리엑트에 집중했던것 같습니다. 이것을 말하는 이유는 저와 비슷한 초보자들도 읽어볼 수 있을 만한 글이라는것을 말씀드리고 싶어서 입니다.</p><p>다음은 저자가 14개의 파트로 나눠서 작업한 부분들을 번역하면서 간단히 요약해 놓은 부분입니다. </p><hr><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><ul><li><p>전체적으로 두가지 프로세스를 다루고 있습니다 : <strong>‘마운트’와 ‘업데이트’</strong></p><ul><li>마운트 : 파트 1~7 / 시작 : ReactDOM.render</li><li>업데이트 : 파트 8~14 / 시작 : component.setState </li></ul></li><li><p>코드에 상응하는 전체 스키마가 있는 것은 아닙니다.</p></li><li><p>마지막에 보이는 샘플 코드는 앞으로 나오는 파트들에 꾸준히 예제로 쓰이고 있습니다.</p></li></ul><div class="alert info"><p>각 파트별로 해당되는 스키마를 잘라서 보여주기는 합니다만 <strong>전체 스키마</strong>와 <strong>샘플코드</strong>를 항상 띄워 놓고 다음 파트들을 살펴보면 보면 이해가 좀 더 수월한 것 같습니다.</p></div><hr><h3 id="파트-0"><a href="#파트-0" class="headerlink" title="파트 0"></a>파트 0</h3><h4 id="ReactDom-render"><a href="#ReactDom-render" class="headerlink" title="ReactDom.render"></a>ReactDom.render</h4><ul><li>앱의 시작은 ReactDom.render에서 부터 시작됩니다.<ul><li>JSX가 리엑트의 엘리먼트되는 시작이며, 이건 단순히 plain objects에 불과합니다.</li><li>실제로, ReactDOM에는 로직이 없고, <code>ReactMount</code>를 사용하기 위한 인터페이스일 뿐입니다. 따라서 <code>ReactDOM.render</code>를 호출하면 기술적으로 <code>ReactMount.render</code>를 호출합니다.</li></ul></li></ul><blockquote><p><strong>마운팅이란?</strong><br>  DOM 엘리먼트를 생성하고 제공된 container에 삽입하여 리엑트 컴포넌트를 초기화하는 작업입니다.</p></blockquote><h4 id="React-컴포넌트-인스턴스화"><a href="#React-컴포넌트-인스턴스화" class="headerlink" title="React 컴포넌트 인스턴스화"></a>React 컴포넌트 인스턴스화</h4><ul><li>가장 먼저 TopLevelWrapper의 인스턴스화가 먼저 일어나면서 트리를 렌더링 합니다.</li></ul><div class="alert info"><p>JSX를 작성해보셨다면, JSX 사용시 하나의 root 엘리먼트로 감싸주어야 한다는 사실을 알고있으실 텐데요. 그게 바로 TopLevelWrapper라고 생각하시면 될 것 같습니다.</p></div><ul><li><p>JSX는 내부 컴포넌트로 변환됨</p></li><li><p>내부 컴포넌트의 종류</p><ul><li>ReactCompositeComponent : 자체 컴포넌트 클래스</li><li>ReactDOMComponent : HTML 태그 클래스</li><li>ReactDOMTextComponent : text nodes 클래스</li></ul></li><li><p>Virtual DOM</p><ul><li>Virtual DOM은 리엑트가 diff 중에 DOM을 직접 건드리지 않는데 사용되는 DOM 표현의 일종.(개념)</li><li>Virtual DOM은 위 3개의 내부 컴포넌트를 참조.</li></ul></li></ul><div class="alert info"><p>마운트라는 개념을 잘 생각해보고, 내부 컴포넌트의 종류 잘 기억하는게 좋은것 같습니다. </p></div><hr><h3 id="파트-1"><a href="#파트-1" class="headerlink" title="파트 1"></a>파트 1</h3><h4 id="Transaction-1"><a href="#Transaction-1" class="headerlink" title="Transaction(1)"></a>Transaction(1)</h4><ul><li><p><code>ReactUpdates</code>모듈을 통해 컴포넌트 인스턴스가 리엑트 생태계에 연결 되도록 합니다.</p></li><li><p>리엑트는 chunks 형태로 업데이트를 수행하기 때문에 사전/사후 처리를 한번만 적용할 수 있도록 트렌젝션을 활용합니다.</p></li><li><p>리엑트에서 트렌잭션이 어떻게 사용되고 있는지 말하고 있습니다.</p><ul><li><code>Transaction</code> 모듈에서 확장하여 사용되며, <strong>어떤 트렌잭션 래퍼로 감싸는지에 따라 목적이 달라집니다.</strong></li><li>래퍼는 기본적으로는 초기화 및 클로즈 메소드를 포함한 객체입니다.</li></ul></li><li><p><code>ReactDefaultBatchingStrategyTransaction</code>레퍼에는 ‘FLUSH_BATCHED_UPDATES’, ‘RESET_BATCHED_UPDATES’래퍼가 존재합니다.</p><ul><li>내부에서 <code>initialize</code> 메소드가 비어있지만, <code>close</code>에는 <code>ReactUpdates.flushBatchedUpdates</code>를 호출합니다.</li><li><code>ReactUpdates.flushBatchedUpdates</code>는 dirty 컴포넌트에 대한 검증을 시작합니다. (파트 8 이후)</li></ul></li></ul><div class="alert info"><p>해당 컴포넌트가 마운팅 되기전에 일련 작업들을 한번에 처리하기위해 <strong>트렌젝션</strong>을 사용해서 진행되고 있습니다.</p></div><hr><h3 id="파트-2"><a href="#파트-2" class="headerlink" title="파트 2"></a>파트 2</h3><h4 id="Transaction-2"><a href="#Transaction-2" class="headerlink" title="Transaction(2)"></a>Transaction(2)</h4><ul><li><p>파트 1의 트렌젝션에서의 메소드 실행부분에서 발생되는 또 다른 트렌잭션.</p></li><li><p>여기에서는 트랜젝션이 다음을 제어하는데 사용됩니다.</p><ul><li>현재 선택한 영역이 다른 영역들로부터 침범되지 않도록 합니다.</li><li>리플로우가 발생되는 정도의 DOM 조작 발생 가능성이 있는 이벤트를 제한합니다.</li><li>이런 과정을 <code>initialize</code> 할 때 제한하고, <code>close</code> 할때 사용하도록 설정합니다.</li></ul></li><li><p>파트 2의 메소드 실행시 <code>ReactReconciler.mountComponent</code>로 DOM에 넣을 준비가 된 마크업을 리턴합니다.</p></li></ul><div class="alert info"><p>랜더링을 위한 마크업을 만들기 전에 다른 영역에 영향을 미칠 수 있는 부분을 제한하는데 이를 <strong>트랜젝션</strong>을 활용하고 있다는 것을 알 수 있습니다.   </p></div><hr><h3 id="파트-3"><a href="#파트-3" class="headerlink" title="파트 3"></a>파트 3</h3><h4 id="Mount"><a href="#Mount" class="headerlink" title="Mount"></a>Mount</h4><ul><li><p>컴포넌트의 트리에 처음 삽입되는 컴포넌트는 TopLevelWrapper 입니다.</p><ul><li>이후에 자식의 자식들도 같은 방식으로 마운트 됩니다. </li></ul></li><li><p>ExampleApplication 컴포넌트에 대한 ReactCompositeComponent 인스턴스 생성(new ExampleApplication())</p><ul><li>생성자를 통해 인스턴스에 props, context, refs, updater가 할당됩니다.<br>(updater는 setState에 의해 사용됩니다.)</li></ul></li></ul><h4 id="초기-마운트-수행"><a href="#초기-마운트-수행" class="headerlink" title="초기 마운트 수행"></a>초기 마운트 수행</h4><ul><li><p>초기 마운트 수행</p><ul><li>componentWillMount가 호출됩니다.</li><li>updater가 할당되었기 때문에 componentWillMount안에서 setState를 사용할 수는 있습니다.<br>   하지만 render()전에 호출되기 때문에 컴포넌트가 아직 마운트 되지 않았기 때문에, state를 알 수 가 없어 state를 설정해도 리렌더링이 발생되지 않습니다.</li><li>componentDidMount 트랜젝션 큐에 넣어둡니다.(이후에 실행되기 때문에)     </li><li>render()가 호출됩니다.</li></ul></li><li><p>render 메소드에서 얻은 엘리먼트를 기반으로 그 자식에 대한 가상 컴포넌트(ReactDOMComponent 인스턴스)를 생성합니다.</p><ul><li>ReactReconciler.mountComponent() 호출합니다.</li></ul></li></ul><div class="alert info"><ul><li>코드랑 매칭 시켜서 이해해 볼 수 있는 첫번째 부분입니다. <code>constructor</code>, 라이프 사이클 메소드인 <code>componentWillMount</code>와 <code>componentDidMount</code>를 연결시켜 볼 수 있습니다.</li><li>컴포넌트의 인스턴스를 만들면서 ReactCompositeComponent(내부 컴포넌트)를 만들고, 그 자식의 인스턴스를 만들어 ReactDOMComponent(HTML 컴포넌트)까지 생성합니다.</li></ul></div><hr><h4 id="파트-4"><a href="#파트-4" class="headerlink" title="파트 4"></a>파트 4</h4><ul><li><p>HTML 태그에서 video, form, textarea의 경우에는 추가 래핑을 진행합니다.</p></li><li><p>내부 props가 올바르게 설정되었는지 확인하기 위해 유효성 검사 메서드를 호출합니다.</p></li><li><p>실제 HTML 엘리먼트는 document.createElement에 의해 생성됩니다.</p></li></ul><hr><h4 id="파트-5"><a href="#파트-5" class="headerlink" title="파트 5"></a>파트 5</h4><ul><li>이전 props와 새 props의 차이를 계산합니다.<ul><li>순서 : 스타일 업데이트 -&gt; 트랜잭션 패턴을 이용해 이벤트 처리 -&gt; attribute, property 업데이트</li></ul></li></ul><hr><h4 id="파트-6"><a href="#파트-6" class="headerlink" title="파트 6"></a>파트 6</h4><ul><li><p>자식 요소들을 관리하는 <code>ReactMultiChild</code> 모듈의 <code>mountChildren</code>메소드를 통해 자식요소들을 인스턴스화하고 마운팅합니다.</p></li><li><p>전반적인 마운팅 프로세스에 대한 전체적인 확인</p><ul><li>커스텀 컴포넌트 인스턴스 생성(<code>constructor</code> 호출)<br>-&gt; render 메소드 호출로 랜더링 진행 하고 <code>React.createElement</code>로 엘리먼트 생성<br>-&gt; 커스텀 컴포넌트가 리턴된 경우 ‘ReactCompositeComponent’로 인스턴스 화하고 HTML인 경우 <code>ReactDOMComponent</code>로 인스턴스화 함<br>-&gt; 반복하면서 DOM 엘리먼트가 생성되면 이벤트 리스너를 할당하면서 DOM 컴포넌트를 마운트합니다.<br>-&gt; 다음 자식들을 이어서 위의 동작들을 반복합니다.</li></ul></li></ul><hr><h3 id="파트-7"><a href="#파트-7" class="headerlink" title="파트 7"></a>파트 7</h3><ul><li><p>마운팅 메소드 실행의 결과로 document에 세팅할 준비가 된 HTML 엘리먼트를 가질 수 있었지만, 실제로는 HTML 마크업이 아닌, children, node(실제 DOM 노드)등의 필드를 가진 데이터 구조입니다.</p></li><li><p>parentNode.insertBefore로 인해 드디어 document에 엘리먼트가 추가됩니다.</p></li><li><p>아직 트렌젝션의 중간 단계이기 때문에 상위 두 단계의 트렌젝션을 모두 닫아줍니다(파트2).</p></li></ul><hr><p>여기까지가 마운팅 프로세스에 대한 일련의 과정입니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Under-the-hood-ReactJS를 읽어보면서 이해한 부분을 정리해보았습니다.&lt;br&gt;Intro ~ 파트7까지의 마운트 부분에 대한 설명이 있습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/categories/js/lib/react/"/>
    
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/tags/react/"/>
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Redux 코드로 이해하기</title>
    <link href="https://jae-kwang.github.io/blog/2017/06/21/redux-use/"/>
    <id>https://jae-kwang.github.io/blog/2017/06/21/redux-use/</id>
    <published>2017-06-20T23:17:00.000Z</published>
    <updated>2017-10-11T00:30:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="리덕스를-코드로-이해해보자"><a href="#리덕스를-코드로-이해해보자" class="headerlink" title="리덕스를 코드로 이해해보자"></a>리덕스를 코드로 이해해보자</h3><p>리엑트를 공부하다 보면 자연스럽게 리덕스를 접하게 됩니다.<br>리덕스를 이해하기 위해 많은 문서를 접하지만, 저 같은 경우에는 코드랑 연결이 되어 있을 때 가장 잘 이해하는 것 같습니다. 그래서 코드로 리덕스를 접근해보려고 합니다.</p><a id="more"></a><h3 id="리덕스의-단어들"><a href="#리덕스의-단어들" class="headerlink" title="리덕스의 단어들"></a>리덕스의 단어들</h3><p>“리덕스는 뭐다.”라는 부분은 많은 문서에서 잘 정리되어 있고, 저 또한 그런 곳을 많이 참조하여 읽습니다.<br>그래서 저는 제가 이해한 만큼에서 직접 사용되는 리덕스의 단어들을 코드로써 이야기해 보려고 합니다.</p><h4 id="1-스토어-Store"><a href="#1-스토어-Store" class="headerlink" title="1. 스토어(Store)"></a>1. 스토어(Store)</h4><p>가장 먼저 스토어 입니다. 스토어는 리덕스를 처음 접하자마자 들을 수 있는 단어로 <strong>state(상태 값)</strong>총괄하는 부분입니다. state는 각 컴포넌트가 갖는 특정한 값일 수도 있으며, UI의 상태를 나타낼 수 있습니다.</p><figure class="highlight javascript"><figcaption><span>스토어 형태</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    color: <span class="string">'black'</span>,</span><br><span class="line">    number: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴포넌트들은 이 스토어에 액션을 dispatch하고, subscribe 하며 상태를 반영할 수 있습니다.<br>액션, dispatch는 천천히 알아보도록 하죠. </p><h4 id="2-액션-action"><a href="#2-액션-action" class="headerlink" title="2. 액션(action)"></a>2. 액션(action)</h4><p>스토어에 대한 값을 변경하기 위해서 어떤 신호를 보내주어야 하는데 바로 그게 바로 액션입니다.</p><p>예를 들어 컴포넌트에서 어떤 이벤트가 발생한 경우 컴포넌트가 “이벤트가 발생했어! 값을 변화시켜줘!”라고 말하는 상태에 대한 변경 값이 들어 있습니다.</p><p>액션은 무엇이냐? 그냥 객체입니다.<br>다만, 한가지 알아두어야 하는 건 모든 액션객체는 <strong>‘type’</strong>이라는 값을 지닙니다.<br><figure class="highlight javascript"><figcaption><span>액션 형태</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">"INCREMENT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>추가로 이벤트 발생 후 변경할 값을 같이 전달해 주려면 아래와 같이 단순히 값을 추가하면 됩니다.</p><figure class="highlight javascript"><figcaption><span>액션 + 값 추가</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">"SET_COLOR"</span>,</span><br><span class="line">    color: <span class="string">"black"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-리듀서-reducers"><a href="#3-리듀서-reducers" class="headerlink" title="3. 리듀서(reducers)"></a>3. 리듀서(reducers)</h4><p>리듀서는 액션을 받아서 스토어의 값을 처리하는 작업을 해줍니다.<br>사실, 스토어는 그냥 저장소일 뿐 아무것도 하지 않습니다. 이 리듀서가 바리바리 움직여서 스토어의 값을 변화시켜줍니다.</p><p>그럼 코드로서는 어떨까요? 리듀서는 스토어의 값을 변형시켜준다고 했습니다.<br>위에서 언급된 것처럼 스토어는 값을 담은 객체일 뿐이고 리듀서는 그 값을 변경한다고 했으니 스토어라는 객체의 값을 변경시켜주는 함수일 뿐이죠.</p><p>대신 액션을 받아서 어떤 값인지 판단해서 어떻게 변경해줘야 할지 분기해야 햐죠.<br>그럼 그 부분을 코드로 작성해보면 아래와 같이 됩니다.</p><figure class="highlight javascript"><figcaption><span>스토어 + 리듀서</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 스토어</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    color: <span class="string">'black'</span>,</span><br><span class="line">    number: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리듀서</span></span><br><span class="line"><span class="comment">// 1. state에 store로 설정한 값을 초기값으로 넣습니다.(처음 스토어가 생성됩니다.)</span></span><br><span class="line"><span class="comment">// 2. action에는 지정한 action 객체가 들어옵니다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exampleReducers</span>(<span class="params">state = initState, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> types.INCREMENT: </span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                number: state.number + <span class="number">1</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> types.SET_COLOR:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                color: action.color</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> exampleReducers;</span><br></pre></td></tr></table></figure><h3 id="4-액션-생성자-Action-Creator"><a href="#4-액션-생성자-Action-Creator" class="headerlink" title="4. 액션 생성자(Action Creator)"></a>4. 액션 생성자(Action Creator)</h3><p>사실 액션 설명할 때 액션 생성자를 같이 설명하는데, 리듀서 다음에 나온 이유는 제가 이해한 흐름대로 나열하기 때문이죠.</p><p>처음 예제들을 참고하며 공부했을 때 혼동이 있었던 부분이었습니다.<br>액션을 리듀서에 전달할 때 “액션 타입을 지정하는 파일(ActionTypes.js)을 만들고, 액션 생성자를 통해서, 리듀서로 전달한다.”라는 말이 직관적으로 머리에 들어오지 않았습니다.</p><p>그래서 저는 저 나름대로 이해를 했습니다.</p><blockquote><p>Q. 액션 생성자를 만드는 이유.<br>A. 매번 객체(액션 객체)를 만들기 귀찮아서.</p></blockquote><blockquote><p>Q. ActionTypes.js란 파일을 만드는 이유.<br>A. 매번 문자열로 전달하면 귀찮아서.</p></blockquote><h3 id="5-디스패치-dispatch"><a href="#5-디스패치-dispatch" class="headerlink" title="5. 디스패치(dispatch)"></a>5. 디스패치(dispatch)</h3><p>액션 생성자와 디스패치의 설명 순서는 좀 애매했습니다.<br>액션 생성자를 설명할 때 “귀찮다”가 언제 인지를 알아야 사용의 편리함을 아니까요.</p><p>바로 디스패치를 통해 액션을 전달할 때 귀찮습니다.</p><p>이 단락에 액션 생성자 코드를 넣는 건 이상하지만 흐름으로는 이게 맞아 보여서 여기에 쓰겠습니다.<br>정말 이름 그대로 액션이란 객체를 만들어주는 객체(액션) 생성자일 뿐입니다.</p><figure class="highlight javascript"><figcaption><span>액션생성자</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// () =&gt; (&#123;&#125;) 은, function() &#123; return &#123; &#125; &#125; 와 동일한 의미</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    type: types.INCREMENT</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>디스패치는 컴포넌트에서 특정한 이벤트 발동 시 실행이 됩니다.<br>디스패치는 액션(객체)을 스토어로 넘겨주는 이벤트 트리거라고 생각하면 될 것 같습니다.</p><figure class="highlight javascript"><figcaption><span>컴포넌트</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'../actions'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> (&#123;</span><br><span class="line">    onIncrement: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(actions.increment()),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>onIncrement()가 실행되면 actions.increment()란 액션 생성자를 통해 액션객체를 생성하고 그 액션객체를 dispatch로 리듀서에 전달되는 겁니다.</p><h3 id="6-react-redux"><a href="#6-react-redux" class="headerlink" title="6. react-redux"></a>6. react-redux</h3><p>그렇다면 이 모든 과정에서 어떻게 액션객체를 컴포넌트에서 스토어로 스토어에서 컴포넌트로 공유가 될 수 있을까요? 바로 ‘react-redux’ 가 해줍니다.</p><h4 id="6-1-Provider"><a href="#6-1-Provider" class="headerlink" title="6-1. Provider"></a>6-1. Provider</h4><p>redux 에서 store는 단 하나입니다. 그렇다면 이게 어디에 위치하는 게 좋을까요?<br>바로 최상단에서 생성되고 하위로 흐르는 방식입니다.</p><p>이는 Provider로 전달할 수 있습니다.<br><figure class="highlight javascript"><figcaption><span>Provider로 store 전달</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redux 관련 불러오기</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스토어 생성</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provider를 사용해서 스토어를 전달합니다.</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>이렇게 하면 스토어가 컴포넌트로 흐르죠.<br>그럼 컴포넌트에서는 스토어의 state를 어떻게 받으며, action은 어떻게 스토어로 전달이 될까요?</p><h4 id="6-2-Connect"><a href="#6-2-Connect" class="headerlink" title="6-2. Connect"></a>6-2. Connect</h4><p>connect()를 통해 state를 가지며 dispatch를 사용할 수 있습니다.</p><figure class="highlight javascript"><figcaption><span>connect로 action 전달</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> exampleComponent <span class="keyword">from</span> <span class="string">'../components/exampleComponent'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store의 값을 컴포넌트에게 props 형태로 전달합니다.</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">    color: state.color,</span><br><span class="line">    number: state.number</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch를 통해 리듀서로 액션생성자를 전달합니다. props형태로 전달됩니다.</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> (&#123;</span><br><span class="line">    onDecrement: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(actions.decrement())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect를 사용하여 스토어와 컴포넌트와 연결을 해줍니다.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(exampleComponent);</span><br></pre></td></tr></table></figure><h3 id="7-미들웨어-middleware"><a href="#7-미들웨어-middleware" class="headerlink" title="7. 미들웨어(middleware)"></a>7. 미들웨어(middleware)</h3><p>미들웨어는 이름답게 중간에서 뭔가를 처리해줍니다. 그 중간은 바로 액션이 리듀서로 전달되는 사이입니다.</p><p>액션 생성자를 통해 액션이 생성되고 dispatch를 통해 리듀서로 전달되기 전에 어떠한 동작을 추가할 수 있습니다.<br>예를 들어 콘솔을 기록할 수도 있고 액션을 취소시킬 수도 있죠. 다른 액션을 디스패치 할 수도 있습니다.</p><p>미들웨어는 redux 의 applyMiddleware()를 사용해 적용할 수 있습니다.</p><figure class="highlight javascript"><figcaption><span>redux-logger 미들웨어 사용하기</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> modules <span class="keyword">from</span> <span class="string">'./modules'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createLogger &#125; <span class="keyword">from</span> <span class="string">'redux-logger'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = createLogger(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(modules, applyMiddleware(logger))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><h3 id="Redux-flow"><a href="#Redux-flow" class="headerlink" title="Redux flow"></a>Redux flow</h3><p>아래의 그림은 이해한 부분들을 그림으로 그려놓은 Flow입니다.</p><div class="figure " style="width:;"><img class="fig-img" src="redux-cycle.png" alt=""></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;리덕스를-코드로-이해해보자&quot;&gt;&lt;a href=&quot;#리덕스를-코드로-이해해보자&quot; class=&quot;headerlink&quot; title=&quot;리덕스를 코드로 이해해보자&quot;&gt;&lt;/a&gt;리덕스를 코드로 이해해보자&lt;/h3&gt;&lt;p&gt;리엑트를 공부하다 보면 자연스럽게 리덕스를 접하게 됩니다.&lt;br&gt;리덕스를 이해하기 위해 많은 문서를 접하지만, 저 같은 경우에는 코드랑 연결이 되어 있을 때 가장 잘 이해하는 것 같습니다. 그래서 코드로 리덕스를 접근해보려고 합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/categories/js/lib/react/"/>
    
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/tags/react/"/>
    
      <category term="redux" scheme="https://jae-kwang.github.io/blog/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>immutable.js 알아보기</title>
    <link href="https://jae-kwang.github.io/blog/2017/06/11/immutable-js/"/>
    <id>https://jae-kwang.github.io/blog/2017/06/11/immutable-js/</id>
    <published>2017-06-11T06:30:30.000Z</published>
    <updated>2017-10-11T00:32:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Immutable-js-란"><a href="#Immutable-js-란" class="headerlink" title="Immutable.js 란?"></a>Immutable.js 란?</h3><p>React를 접했을 때 immutable.js도 같이 알 되었는데, 당시에는 정확히 왜 필요한지 몰랐습니다.<br>하지만 몇 번 보다 보니 그 이유를 알게 되었고, 제가 이해한 부분과 사용법을 정리해보려고 합니다.</p><a id="more"></a><h4 id="객체의-불변성"><a href="#객체의-불변성" class="headerlink" title="객체의 불변성"></a>객체의 불변성</h4><p>처음 ‘immutable:불변성’이란 단어는 낯설고 머리에 잘 와닿지 않았습니다.<br>불변성…불변성… 발음도 힘듭니다. 😧</p><p>저는 머리가 좋지 않은 관계로 한번은 더 풀어서 이해해야 했습니다. </p><blockquote><p>내가 만드는 객체는 절대 변하지 않아, 그러니까 수정하려면 반드시 다른 걸 하나 새로 만들어야 해!</p></blockquote><p>React에서는 state 혹은 props에 변화가 감지되면 컴포넌트를 리랜더링합니다.</p><span class="highlight-text danger">그런데 레퍼런스 값으로 데이터를 가지고 있는 정보들은 값이 달라져도, 레퍼런스가 같기 때문에 React는 값의 변화를 인지하지 못합니다.</span><p>그래서 객체를 새로 만들어주어야 하는데 이때 immutable.js을 통해 더욱 손쉽게 데이터를 변경할 수 있습니다.</p><h4 id="Without-immutable-js"><a href="#Without-immutable-js" class="headerlink" title="Without immutable.js"></a>Without immutable.js</h4><p>우선 immutable.js 없이 값을 수정하는 예제를 한번 확인해보시죠.</p><p>React에서는 위에도 언급했듯 레퍼런스를 활용하는 데이터의 경우에는 새로운 값을 만들어 연결해주어야 하는데, 다음 예제와 같이 데이터가 배열인 경우 특정 idx 내부의 값을 변경할 때는 아래와 같이 적용해 볼 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Items: [</span><br><span class="line">    ...Items.slice(<span class="number">0</span>, idx),</span><br><span class="line">    &#123;</span><br><span class="line">      ...item,</span><br><span class="line">      tempValue: !item.tempValue</span><br><span class="line">    &#125;,</span><br><span class="line">    ...Items.slice(idx + <span class="number">1</span>, Items.length)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol><li>기존 배열에서 slice()를 사용해 idx까지 배열을 자른다.</li><li>수정할 idx의 데이터를 수정한다.</li><li>수정한 idx 이후에 데이터를 slice() 통해 자른다.</li><li>3개의 작업 된 데이터를 하나의 배열을 만들어 다시 기존 변수에 넣어준다.</li></ol><div class="alert warning"><p>단순히 값을 변경해주는 부분인데 매우 번거로울 뿐만 아니라, 데이터가 구조가 복잡하거나 많을 때는 더욱 많은 리소스 사용하게 될 것입니다.</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Items[idx].tempValue = !Items[idx].tempValue;</span><br></pre></td></tr></table></figure><p>이렇게 사용해도 정상작동되면 참 좋을 텐데요? 😏</p><h4 id="Use-immutable-js"><a href="#Use-immutable-js" class="headerlink" title="Use immutable.js"></a>Use immutable.js</h4><p>immutable 코드를 쓰기 전엔 8줄의 코드가 3줄로 줄었습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Items = Itmes.update(idx, (item) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> item.set(<span class="string">'tempValue'</span>, !item.get(<span class="string">'tempvalue'</span>)); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>간단히 설명하면, immutable.js에서 제공되는 <span class="highlight-text orange">update</span>를 활용하여 변경하고자 하는 idx를 받아 해당 위치의 값을 <span class="highlight-text orange">set</span>로 수정하는데<span class="highlight-text orange">get</span>를 사용해 현재 값을 받아 변경합니다.<br><div class="alert info"><p>게다가 더 빠르다고 합니다.<br><a href="http://blog.klipse.tech/javascript/2016/06/23/immutable-perf.html" target="_blank" rel="external">http://blog.klipse.tech/javascript/2016/06/23/immutable-perf.html</a></p></div></p><h3 id="immutable-js-간단-사용법"><a href="#immutable-js-간단-사용법" class="headerlink" title="immutable.js 간단 사용법"></a>immutable.js 간단 사용법</h3><h5 id="1-데이터-생성"><a href="#1-데이터-생성" class="headerlink" title="1. 데이터 생성"></a>1. 데이터 생성</h5><p>immutable을 사용하면 객체는 MAP으로 감싸주어야 합니다.<br>배열의 경우에는 List로 감싸줍니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic object</span></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="number">3</span>,</span><br><span class="line">    e: <span class="number">4</span>,</span><br><span class="line">    f: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use immutable.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">Map</span> = Immutable.Map;</span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">Map</span>(&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="built_in">Map</span>(&#123;</span><br><span class="line">    d: <span class="number">3</span>,</span><br><span class="line">    e: <span class="number">4</span>,</span><br><span class="line">    f: <span class="number">5</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="2-데이터-읽기"><a href="#2-데이터-읽기" class="headerlink" title="2. 데이터 읽기"></a>2. 데이터 읽기</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 자바스크립트 객체로 변환하기 */</span></span><br><span class="line">data.toJS(); <span class="comment">// &#123; a:1, b:2, c: &#123; d: 3, e: 4, f: 5 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 특정 키의 값 얻어오기 */</span></span><br><span class="line">data.get(<span class="string">'a'</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 내부의 키의 값 얻어오기 */</span></span><br><span class="line">data.getIn([<span class="string">'c'</span>, <span class="string">'d'</span>]) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h5 id="3-데이터-수정"><a href="#3-데이터-수정" class="headerlink" title="3. 데이터 수정"></a>3. 데이터 수정</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 값 설정하기 */</span></span><br><span class="line"><span class="keyword">var</span> newData = data.set(<span class="string">'a'</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 내부의 값 설정하기 */</span></span><br><span class="line"><span class="keyword">var</span> newData = data.setIn([<span class="string">'c'</span>, <span class="string">'d'</span>], <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 내부의 객체를 설정하기 */</span></span><br><span class="line"><span class="keyword">var</span> newData = data.set(<span class="string">'c'</span>, <span class="built_in">Map</span>(&#123; <span class="attr">d</span>: <span class="number">10</span>, <span class="attr">e</span>: <span class="number">10</span>, <span class="attr">f</span>: <span class="number">10</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 값 여러개 설정하기 */</span></span><br><span class="line"><span class="keyword">var</span> newData = data.merge(&#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">10</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* nest된 키에 값 여러개 설정하기 */</span></span><br><span class="line"><span class="keyword">var</span> newData = data.mergeIn([<span class="string">'c'</span>], &#123; <span class="attr">d</span>: <span class="number">10</span>, <span class="attr">e</span>: <span class="number">10</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* List 일경우 값 추가하기 */</span></span><br><span class="line"><span class="keyword">var</span> newList = list.push(<span class="built_in">Map</span>(&#123;<span class="attr">value</span>: <span class="number">3</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* List 일경우 값 앞에 추가하기 */</span></span><br><span class="line"><span class="keyword">var</span> newList = list.unshift(<span class="built_in">Map</span>(&#123;<span class="attr">value</span>: <span class="number">0</span>&#125;))</span><br></pre></td></tr></table></figure><h5 id="4-데이터-삭제"><a href="#4-데이터-삭제" class="headerlink" title="4. 데이터 삭제"></a>4. 데이터 삭제</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 아이템 제거 */</span></span><br><span class="line"><span class="keyword">var</span> newList = list.delete(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 가장 마지막 아이템 제거 */</span></span><br><span class="line"><span class="keyword">var</span> newList = list.pop();</span><br></pre></td></tr></table></figure><p>공식 페이지 : <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="external">https://facebook.github.io/immutable-js/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Immutable-js-란&quot;&gt;&lt;a href=&quot;#Immutable-js-란&quot; class=&quot;headerlink&quot; title=&quot;Immutable.js 란?&quot;&gt;&lt;/a&gt;Immutable.js 란?&lt;/h3&gt;&lt;p&gt;React를 접했을 때 immutable.js도 같이 알 되었는데, 당시에는 정확히 왜 필요한지 몰랐습니다.&lt;br&gt;하지만 몇 번 보다 보니 그 이유를 알게 되었고, 제가 이해한 부분과 사용법을 정리해보려고 합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="immutable" scheme="https://jae-kwang.github.io/blog/categories/js/lib/immutable/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="immutable.js" scheme="https://jae-kwang.github.io/blog/tags/immutable-js/"/>
    
  </entry>
  
  <entry>
    <title>React에서 컴포넌트 스타일링 하기</title>
    <link href="https://jae-kwang.github.io/blog/2017/06/06/react-component_style/"/>
    <id>https://jae-kwang.github.io/blog/2017/06/06/react-component_style/</id>
    <published>2017-06-06T04:30:00.000Z</published>
    <updated>2017-10-11T00:30:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="컴포넌트-스타일-적용하기"><a href="#컴포넌트-스타일-적용하기" class="headerlink" title="컴포넌트 스타일 적용하기"></a>컴포넌트 스타일 적용하기</h3><p>리엑트는 컴포넌트들을 작성할때 어떤식으로 스타일을 입힐 수 있을까요?</p><a id="more"></a><h4 id="1-Basic-CSS"><a href="#1-Basic-CSS" class="headerlink" title="1. Basic CSS"></a>1. Basic CSS</h4><p>React도 다른 웹구현 방식과 동일하게 Head에서 link 태그를 통해 css를 불러와 적용할 수 있습니다.<br>물론 style 태그를 통해 직접 스타일을 작성하는 것도 가능하죠.</p><p>편리하긴 하지만 이 방식은 Class name의 중복성을 피할수가 없습니다.</p><p>게다가 이렇게 사용하면 컴포넌트 중심으로 구현되는 React와는 조금 동떨어진 느낌입니다.</p><h4 id="2-CSS-Module"><a href="#2-CSS-Module" class="headerlink" title="2. CSS Module"></a>2. CSS Module</h4><p>글보다는 우선 예제를 보시죠</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./table.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.table&#125;</span>&gt;</span></span></span><br><span class="line">            &lt;div className=&#123;styles.row&#125;&gt;</span><br><span class="line">                &lt;div className=&#123;styles.cell&#125;&gt;A0&lt;/div&gt;</span><br><span class="line">                &lt;div className=&#123;styles.cell&#125;&gt;B0&lt;/div&gt;</span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드처럼 .css를 import로 불러와서 컴포넌트에서 .으로 접근하여 사용하는 방식입니다.<br>보다 컴포넌트별로 구분할 수 있고 접근하기도 좀 더 명확해 보입니다.</p><p><a href="https://github.com/gajus/react-css-modules" target="_blank" rel="external">CSS Module</a>는 webpack을 이용하여 사용할 수 있습니다.</p><p>저도 webpack을 잘하면 떡주무르듯 위의 링크에서 적용하라는 대로 해서 사용할 수 있겠는데,<br>아직 webpack을 잘 모르는 상태라서 생각보다 적용이 쉽지 않네요.</p><p>그래서 create-react-app에서 eject를 해서 설정을 변경해서 적용해보았는데 저도 1번 방식이으로 하다가 컴포넌트 단위로 작업해보니 조금 새로웠습니다.</p><p>여기에 더불어 여러 classname을 적용할때 es6 template literals을 사용하지 않고도 편리하게 적용할 수 있는 <a href="https://github.com/JedWatson/classnames" target="_blank" rel="external">classnames</a>을 사용하거나 sass나 less 같은 preprocessor를 적용하여 사용할 수 있습니다.</p><h4 id="3-styled-components"><a href="#3-styled-components" class="headerlink" title="3. styled-components"></a>3. styled-components</h4><p><a href="https://www.styled-components.com/" target="_blank" rel="external">styled-components</a>는 컴포넌트 자체가 스타일을 입고 태어난다고 말할 수 있을것 같습니다.</p><p>아래와 같이 사용됩니다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  border-radius: 3px;</span></span><br><span class="line"><span class="string">  padding: 0.25em 1em;</span></span><br><span class="line"><span class="string">  margin: 0 1em;</span></span><br><span class="line"><span class="string">  background: transparent;</span></span><br><span class="line"><span class="string">  color: palevioletred;</span></span><br><span class="line"><span class="string">  border: 2px solid palevioletred;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;props =&gt; props.primary &amp;&amp; css<span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    background: palevioletred;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    color: white;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>&#125;</span></span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>해당 스타일 방식은 컴포넌트 자체에 스타일을 입히기 때문에 props를 받아서 바로 스타일에 적용할 수도 있다는게 장점입니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;컴포넌트-스타일-적용하기&quot;&gt;&lt;a href=&quot;#컴포넌트-스타일-적용하기&quot; class=&quot;headerlink&quot; title=&quot;컴포넌트 스타일 적용하기&quot;&gt;&lt;/a&gt;컴포넌트 스타일 적용하기&lt;/h3&gt;&lt;p&gt;리엑트는 컴포넌트들을 작성할때 어떤식으로 스타일을 입힐 수 있을까요?&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/categories/js/lib/react/"/>
    
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Underscore의 _.reduceRight</title>
    <link href="https://jae-kwang.github.io/blog/2017/05/23/underscore-reduceRight/"/>
    <id>https://jae-kwang.github.io/blog/2017/05/23/underscore-reduceRight/</id>
    <published>2017-05-23T00:14:00.000Z</published>
    <updated>2017-10-11T00:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Underscore-의-reduceRight"><a href="#Underscore-의-reduceRight" class="headerlink" title="Underscore 의 _.reduceRight"></a>Underscore 의 _.reduceRight</h3><p>v1부터 현재까지 코드가 어떻게 변해왔는지 확인해봅니다.</p><a id="more"></a><p>reduceRight는 reduce를 내림차순으로 수행하는 함수입니다.</p><p>[~v0.3.3]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = <span class="function"><span class="keyword">function</span>(<span class="params">obj, memo, iterator, context</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (obj &amp;&amp; obj.reduceRight) <span class="keyword">return</span> obj.reduceRight(_.bind(iterator, context), memo);</span><br><span class="line">   <span class="keyword">var</span> reversed = _.clone(_.toArray(obj)).reverse();</span><br><span class="line">   _.each(reversed, <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">     memo = iterator.call(context, memo, value, index, obj);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">return</span> memo;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><ol><li>기본 reduceRight가 있으면 해당 함수를 사용하도록 합니다.</li><li>조작할 데이터를 _.clone을 통해 복사를 한후 .reverse()를 통해 내림차순으로 돌립니다.</li><li>이후는 reduce와 동일하게 콜백을 수행합니다.</li></ol><hr><p>[~v0.5.1]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = <span class="function"><span class="keyword">function</span>(<span class="params">obj, memo, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; _.isFunction(obj.reduceRight)) <span class="keyword">return</span> obj.reduceRight(_.bind(iterator, context), memo);</span><br><span class="line">  <span class="keyword">var</span> reversed = _.clone(_.toArray(obj)).reverse();</span><br><span class="line">  _.each(reversed, <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    memo = iterator.call(context, memo, value, index, obj);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>reduce함수와 동일하게 같은버전에서 obj에 기본 reduceRight가 있는지 체크하는 방식이 obj.reduceRight _.isFunction(obj.reduceRight)로 변경되었습니다.</li></ol><hr><p>[~v0.6.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = <span class="function"><span class="keyword">function</span>(<span class="params">obj, memo, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) <span class="keyword">return</span> obj.reduceRight(_.bind(iterator, context), memo);</span><br><span class="line">  <span class="keyword">var</span> reversed = _.clone(_.toArray(obj)).reverse();</span><br><span class="line">  <span class="keyword">return</span> _.reduce(reversed, memo, iterator, context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>native ReduceRight를 체크하는 코드가 추가 및 변경되었습니다.(reduce와 동일합니다.)</li><li>반복문 도는 구간이 <em>.each에서 </em>.reduce로 대체되었습니다.</li></ol><hr><p>[~v1.1.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, memo, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context) iterator = _.bind(iterator, context);</span><br><span class="line">    <span class="keyword">return</span> obj.reduceRight(iterator, memo);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> reversed = _.clone(_.toArray(obj)).reverse();</span><br><span class="line">  <span class="keyword">return</span> _.reduce(reversed, iterator, memo, context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>reduce와 동일하게 argument의 순서가 변경되었습니다.(내부적으로 누적값에 사용되는 memo argument와 interator argument)</li></ol><hr><p>[~v1.1.2]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = _.foldr = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, memo, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context) iterator = _.bind(iterator, context);</span><br><span class="line">    <span class="keyword">return</span> obj.reduceRight(iterator, memo);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> reversed = (_.isArray(obj) ? obj.slice() : _.toArray(obj)).reverse();</span><br><span class="line">  <span class="keyword">return</span> _.reduce(reversed, iterator, memo, context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>들어오는 데이터가 배열타입인지 확인후 배열인경우 .slice() 통해 shallow copy로 새로운 배열을 만들고, 배열이 아닌경우 _.toArray로 배열로 변환후 .reverse()를 이용해 내림차순으로 변경합니다.</li><li>foldr란 이름이 생겼습니다.</li></ol><hr><p>[~v1.1.3]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = _.foldr = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, memo, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context) iterator = _.bind(iterator, context);</span><br><span class="line">    <span class="keyword">return</span> memo !== <span class="keyword">void</span> <span class="number">0</span> ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> reversed = (_.isArray(obj) ? obj.slice() : _.toArray(obj)).reverse();</span><br><span class="line">  <span class="keyword">return</span> _.reduce(reversed, iterator, memo, context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>기본 reduceRight를 사용할때 초기값(memo)가 있는지 체크합니다.</li></ol><hr><p>[~v.1.1.4]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = _.foldr = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, memo, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) obj = [];</span><br><span class="line">  <span class="keyword">if</span> (nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context) iterator = _.bind(iterator, context);</span><br><span class="line">    <span class="keyword">return</span> memo !== <span class="keyword">void</span> <span class="number">0</span> ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> reversed = (_.isArray(obj) ? obj.slice() : _.toArray(obj)).reverse();</span><br><span class="line">  <span class="keyword">return</span> _.reduce(reversed, iterator, memo, context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>null체크가 추가되었습니다.</li></ol><hr><p>[~v1.2.3]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = _.foldr = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, memo, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) obj = [];</span><br><span class="line">  <span class="keyword">if</span> (nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context) iterator = _.bind(iterator, context);</span><br><span class="line">    <span class="keyword">return</span> initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> reversed = _.toArray(obj).reverse();</span><br><span class="line">  <span class="keyword">if</span> (context &amp;&amp; !initial) iterator = _.bind(iterator, context);</span><br><span class="line">  <span class="keyword">return</span> initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>초기값인 memo를 판정하는 방법이 reduce와 동일하게 변경되었습니다.</li><li>초기값에 따라 _.reduce를 실행에 필요한 parameter를 다르게 설정합니다.</li></ol><hr><p>[~v1.4.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = _.foldr = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, memo, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context) iterator = _.bind(iterator, context);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>.length &gt; <span class="number">2</span> ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> length = obj.length;</span><br><span class="line">  <span class="keyword">if</span> (length !== +length) &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.keys(obj);</span><br><span class="line">    length = keys.length;</span><br><span class="line">  &#125;</span><br><span class="line">  each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    index = keys ? keys[--length] : --length;</span><br><span class="line">    <span class="keyword">if</span> (!initial) &#123;</span><br><span class="line">      memo = obj[index];</span><br><span class="line">      initial = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      memo = iterator.call(context, memo, obj[index], index, list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!initial) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Reduce of empty array with no initial value'</span>);</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>length가 없는경우 obj의 사이즈를 구하여 length를 대신 확인합니다.</li><li>반복문이 적용되는 구간이 기존 _.reduce 대신 each()를 사용해 내림차순으로 순환하고 있습니다.</li></ol><hr><p>[~v1.7.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = _.foldr = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) obj = [];</span><br><span class="line">  iteratee = createCallback(iteratee, context, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> keys = obj.length !== + obj.length &amp;&amp; _.keys(obj),</span><br><span class="line">      index = (keys || obj).length,</span><br><span class="line">      currentKey;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!index) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(reduceError);</span><br><span class="line">    memo = obj[keys ? keys[--index] : --index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">    currentKey = keys ? keys[index] : index;</span><br><span class="line">    memo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>다른 반목문들과 동일하게 추후 optimizeCb로 변경되는 createCallback function을 사용하여 callback 처리를 하고 있습니다.</li><li>반복구간이 while로 사용되고 있습니다.</li></ol><hr><p>[~v1.8.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.reduceRight = _.foldr = createReduce(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure></p><ol><li>reduce와 반대로 createReduce에 1이 아닌 -1을 넣어 내림차순으로 reduce를 수행되도록 하고 있습니다.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Underscore-의-reduceRight&quot;&gt;&lt;a href=&quot;#Underscore-의-reduceRight&quot; class=&quot;headerlink&quot; title=&quot;Underscore 의 _.reduceRight&quot;&gt;&lt;/a&gt;Underscore 의 _.reduceRight&lt;/h3&gt;&lt;p&gt;v1부터 현재까지 코드가 어떻게 변해왔는지 확인해봅니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="underscore" scheme="https://jae-kwang.github.io/blog/categories/js/lib/underscore/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="underscore.js" scheme="https://jae-kwang.github.io/blog/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>Underscore의 _.reduce</title>
    <link href="https://jae-kwang.github.io/blog/2017/05/10/underscore-reduce/"/>
    <id>https://jae-kwang.github.io/blog/2017/05/10/underscore-reduce/</id>
    <published>2017-05-10T00:52:00.000Z</published>
    <updated>2017-10-11T00:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Underscore-의-reduce"><a href="#Underscore-의-reduce" class="headerlink" title="Underscore 의 _.reduce"></a>Underscore 의 _.reduce</h3><p>v1부터 현재까지 코드가 어떻게 변해왔는지 확인해봅니다.</p><a id="more"></a><p>[~v0.1.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inject : <span class="function"><span class="keyword">function</span>(<span class="params">obj, memo, iterator, context</span>) </span>&#123;</span><br><span class="line">  _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    memo = iterator.call(context, memo, value, index);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>처음에는 reduce란 이름대신 inject란 이름의 함수로 존재합니다.</li><li>실제 결과를 받는 return value 이외에 memo라는 inject내부에서 누적값을 쌓는데 사용되는 변수를 넣어주어야 하는 구조로 되어있습니다.</li><li>map과 다르게 내부 memo에 새로운 값을 할당해줍니다.</li></ol><hr><p>[~v0.2.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_.reduce = <span class="function"><span class="keyword">function</span>(<span class="params">obj, memo, iterator, context</span>) </span>&#123;</span><br><span class="line">  _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    memo = iterator.call(context, memo, value, index);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>reduce로 이름이 변경되었습니다.</li></ol><hr><p>[~v0.3.3]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.reduce = <span class="function"><span class="keyword">function</span>(<span class="params">obj, memo, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.reduce) <span class="keyword">return</span> obj.reduce(_.bind(iterator, context), memo);</span><br><span class="line">  _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    memo = iterator.call(context, memo, value, index, list);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>javascript에서 기본적으로 제공되는 reduce가 사용되도록 하는 코드가 추가되었습니다.</li><li>iterator의 argument에 list를 추가할 수 있게 되었습니다.</li></ol><hr><p>[~v0.5.1]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.reduce = <span class="function"><span class="keyword">function</span>(<span class="params">obj, memo, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; _.isFunction(obj.reduce)) <span class="keyword">return</span> obj.reduce(_.bind(iterator, context), memo);</span><br><span class="line">  _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    memo = iterator.call(context, memo, value, index, list);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>obj에 기본 reduce가 있는지 체크하는 방식이 obj.reduce에서 _.isFunction(obj.reduce)로 변경되었습니다.</li></ol><hr><p>[~v0.6.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.reduce = <span class="function"><span class="keyword">function</span>(<span class="params">obj, memo, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nativeReduce &amp;&amp; obj.reduce === nativeReduce) <span class="keyword">return</span> obj.reduce(_.bind(iterator, context), memo);</span><br><span class="line">  each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    memo = iterator.call(context, memo, value, index, list);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>native reduce체크하는 코드가 추가 및 변경되었습니다.</li></ol><hr><p>[~v1.1.3]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_.reduce = _.foldl = _.inject = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, memo, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> initial = memo !== <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (nativeReduce &amp;&amp; obj.reduce === nativeReduce) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context) iterator = _.bind(iterator, context);</span><br><span class="line">    <span class="keyword">return</span> initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);</span><br><span class="line">  &#125;</span><br><span class="line">  each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!initial &amp;&amp; index === <span class="number">0</span>) &#123;</span><br><span class="line">      memo = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      memo = iterator.call(context, memo, value, index, list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>argument의 순서가 변경되었습니다.(내부적으로 누적값에 사용되는 memo argument와 interator argument)</li><li>foldl와 inject란 이름이 생겼습니다.</li><li>처음 초기값(memo)가 있는지 확인한 후 초기값이 있으면 해당 초기값 이후부터 값을 누적시킵니다.</li></ol><hr><p>[~v1.2.3]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_.reduce = _.foldl = _.inject = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, memo, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) obj = [];</span><br><span class="line">  <span class="keyword">if</span> (nativeReduce &amp;&amp; obj.reduce === nativeReduce) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context) iterator = _.bind(iterator, context);</span><br><span class="line">    <span class="keyword">return</span> initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);</span><br><span class="line">  &#125;</span><br><span class="line">  each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!initial) &#123;</span><br><span class="line">      memo = value;</span><br><span class="line">      initial = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      memo = iterator.call(context, memo, value, index, list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!initial) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Reduce of empty array with no initial value'</span>);</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>reduce을 수행할 데이터와 초기값이 둘 다 없을경우 에러메세지를 보여줍니다. (기본 reduce function이 리턴하는 에러메시지와 동일)</li><li>initial의 체크 방식이 변경되었습니다. memo가 입력됬는지의 유무가 아닌 parameter를 몇 개나 넣어주었는지를 판정합니다.</li><li>null 체크가 추가되었습니다.</li></ol><hr><p>[~v1.7.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reduceError = <span class="string">'Reduce of empty array with no initial value'</span>;</span><br><span class="line"></span><br><span class="line">_.reduce = _.foldl = _.inject = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) obj = [];</span><br><span class="line">  iteratee = createCallback(iteratee, context, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> keys = obj.length !== +obj.length &amp;&amp; _.keys(obj),</span><br><span class="line">      length = (keys || obj).length,</span><br><span class="line">      index = <span class="number">0</span>, currentKey;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!length) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(reduceError);</span><br><span class="line">    memo = obj[keys ? keys[index++] : index++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (; index &lt; length; index++) &#123;</span><br><span class="line">    currentKey = keys ? keys[index] : index;</span><br><span class="line">    memo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>each나 map에서도 사용된 함수인 createCallback가 적용되었습니다.</li><li>keys에는 reduce를 수행할 data가 object형태일 경우에는 object의 key들을 갖고, 배열일 경우 false값을 같습니다.</li><li>초기값이 들어오지 않았을 경우, 배열은 첫번째 인덱스의 값을 초기값으로 잡고, 오브젝트의 경우에도 첫번째 값을 초기값으로 설정합니다.</li><li>기존에 underscore에 제공한 each문이나, js 기본 reduce function을 사용하는 부분이 사라졌습니다.</li></ol><hr><p>[~v1.8.3]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createReduce = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Wrap code that reassigns argument variables in a separate function than</span></span><br><span class="line">  <span class="comment">// the one that accesses `arguments.length` to avoid a perf hit. (#1991)</span></span><br><span class="line">  <span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">        length = (keys || obj).length,</span><br><span class="line">        index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initial) &#123;</span><br><span class="line">      memo = obj[keys ? keys[index] : index];</span><br><span class="line">      index += dir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">      memo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt;= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> reducer(obj, optimizeCb(iteratee, context, <span class="number">4</span>), memo, initial);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.reduce = _.foldl = _.inject = createReduce(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><ol><li>createReduce()를 통해 reduce가 수행되도록 변경되었습니다.</li><li>return 되는 값이 function 지정되게 하여 실행된 parameter를 받는 구조입니다. (ex: function(dir)(argument))</li><li>주석으로 달려있거나 추가적으로 코드 변경에 따른 장점은 더 공부해야 할 필요한 부분인것 같습니다.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Underscore-의-reduce&quot;&gt;&lt;a href=&quot;#Underscore-의-reduce&quot; class=&quot;headerlink&quot; title=&quot;Underscore 의 _.reduce&quot;&gt;&lt;/a&gt;Underscore 의 _.reduce&lt;/h3&gt;&lt;p&gt;v1부터 현재까지 코드가 어떻게 변해왔는지 확인해봅니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="underscore" scheme="https://jae-kwang.github.io/blog/categories/js/lib/underscore/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="underscore.js" scheme="https://jae-kwang.github.io/blog/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>Underscore의 _.map</title>
    <link href="https://jae-kwang.github.io/blog/2017/04/29/underscore-map/"/>
    <id>https://jae-kwang.github.io/blog/2017/04/29/underscore-map/</id>
    <published>2017-04-29T02:15:00.000Z</published>
    <updated>2017-10-11T00:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Underscore-의-map"><a href="#Underscore-의-map" class="headerlink" title="Underscore 의 _.map"></a>Underscore 의 _.map</h3><p>v1부터 현재까지 코드가 어떻게 변해왔는지 확인해봅니다.</p><a id="more"></a><p>[~v0.1.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map : <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.map) <span class="keyword">return</span> obj.map(iterator, context);</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    results.push(iterator.call(context, value, index));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>기존 map function이 있는 기본 function을 사용한다.</li><li>map의 특징 중 하나인 결과값 return을 하는데 _.each의 결과를 results에 저장하는 것을 확인할 수 있다.</li></ol><hr><p>[~v0.5.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.map = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; _.isFunction(obj.map)) <span class="keyword">return</span> obj.map(iterator, context);</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    results.push(iterator.call(context, value, index, list));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>obj.map -&gt; _.isFunction(obj.map) 로 변경됨</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.isFunction = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.constructor &amp;&amp; obj.call &amp;&amp; obj.apply;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>function이 가지고 있는 property를 확인하는 방식으로 만들어져 있습니다.</p><hr><p>[~v0.6.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.map = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nativeMap &amp;&amp; obj.map === nativeMap) <span class="keyword">return</span> obj.map(iterator, context);</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    results.push(iterator.call(context, value, index, list));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>기본 값인지 확인하는 nativeMap 추가되었습니다.<br>(nativeMap = Array.prototype.map)</li><li><em>.each에서 </em>.each가 each로 변경되는데 부분이 있는데 map을 통해 그시기가 다른 내부 함수에서 each를 사용하기 위해 내부적으로 사용되는 경우를 고려해서 변경된것으로 보입니다.</li></ol><hr><p>[~v1.1.1]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.map = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nativeMap &amp;&amp; obj.map === nativeMap) <span class="keyword">return</span> obj.map(iterator, context);</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    results[results.length] = iterator.call(context, value, index, list);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>push 대신에 key에 접근해 직접 값을 할당하는 하는 방식으로 변경됨</li></ol><hr><p>[~v1.1.4]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_.map = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> results;</span><br><span class="line">  <span class="keyword">if</span> (nativeMap &amp;&amp; obj.map === nativeMap) <span class="keyword">return</span> obj.map(iterator, context);</span><br><span class="line">  each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    results[results.length] = iterator.call(context, value, index, list);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>null 값 체크 추가</li></ol><hr><p>[~v1.2.4]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.map = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> results;</span><br><span class="line">  <span class="keyword">if</span> (nativeMap &amp;&amp; obj.map === nativeMap) <span class="keyword">return</span> obj.map(iterator, context);</span><br><span class="line">  each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    results[results.length] = iterator.call(context, value, index, list);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (obj.length === +obj.length) results.length = obj.length;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>result의 length를 별도로 넣는 코드가 추가 됬습니다.<br>key로 접근해 데이터를 넣을때 length가 정확히 측정되지 않는 부분이 있는것 같습니다<br>(추가 확인 필요)</li></ol><hr><p>[~v1.4.2]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_.map = _.collect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> results;</span><br><span class="line">  <span class="keyword">if</span> (nativeMap &amp;&amp; obj.map === nativeMap) <span class="keyword">return</span> obj.map(iterator, context);</span><br><span class="line">  each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    results[results.length] = iterator.call(context, value, index, list);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>_.collect 라는 다른 네이밍이 추가되었습니다.</li></ol><hr><p>[~v1.8.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_.map = _.collect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = cb(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">      length = (keys || obj).length,</span><br><span class="line">      results = <span class="built_in">Array</span>(length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">    results[index] = iteratee(obj[currentKey], currentKey, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>v1.8.0에 공통함수인 function cb에 의해서 _.each와 동일하게 iteratee를 사용하고 있습니다.</li><li>results로 return되는 결과를 for를 돌면서 생성되는 데이터에의 의존되는 방식이 아닌, 미리 값체크를 완료후에 데이터를 삽입하고 있습니다.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Underscore-의-map&quot;&gt;&lt;a href=&quot;#Underscore-의-map&quot; class=&quot;headerlink&quot; title=&quot;Underscore 의 _.map&quot;&gt;&lt;/a&gt;Underscore 의 _.map&lt;/h3&gt;&lt;p&gt;v1부터 현재까지 코드가 어떻게 변해왔는지 확인해봅니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="underscore" scheme="https://jae-kwang.github.io/blog/categories/js/lib/underscore/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="underscore.js" scheme="https://jae-kwang.github.io/blog/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>Underscore의 _.each</title>
    <link href="https://jae-kwang.github.io/blog/2017/04/24/underscore-each/"/>
    <id>https://jae-kwang.github.io/blog/2017/04/24/underscore-each/</id>
    <published>2017-04-24T00:18:00.000Z</published>
    <updated>2017-10-11T00:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Underscore-의-each"><a href="#Underscore-의-each" class="headerlink" title="Underscore 의 _.each"></a>Underscore 의 _.each</h3><p>v1부터 현재까지 코드가 어떻게 변해왔는지 확인해봅니다.</p><a id="more"></a><p>[~v0.1.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>._ = &#123;</span><br><span class="line">  each : <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.forEach) &#123;</span><br><span class="line">        obj.forEach(iterator, context);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;obj.length; i++) iterator.call(context, obj[i], i);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.each) &#123;</span><br><span class="line">        obj.each(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; iterator.call(context, value, index++); &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">          <span class="keyword">var</span> value = obj[key], pair = [key, value];</span><br><span class="line">          pair.key = key;</span><br><span class="line">          pair.value = value;</span><br><span class="line">          iterator.call(context, pair, i++);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">'__break__'</span>) <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>window객체에 _.each function을 직접 할당해서 사용하고 있습니다.</li><li>데이터가 배열, 기본 배열이 아닌 리스트 (ex. 문자열, jQuery), 객체인 경우 loop가 적용되고 있습니다.<br>(obj.each는 뭐지?)</li></ol><hr><p>[~v0.3.1]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_.each = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.forEach) &#123;</span><br><span class="line">      obj.forEach(iterator, context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, l = obj.length; i&lt;l; i++) iterator.call(context, obj[i], i, obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.each) &#123;</span><br><span class="line">      obj.each(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; iterator.call(context, value, index++, obj); &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">        iterator.call(context, obj[key], key, obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="string">'__break__'</span>) <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>v2 버전에서 window객체가 없을 때도 사용되도록 전체 구조가 변경되었습니다.</li><li>들어오는 데이터가 객체일 경우 프로퍼티 값이 있는지 확인하는 코드가 추가 되었습니다.</li><li>iterator.call의 argument값이 달라졌습니다. 하나의 obj가 아니라 각각의 값을 넣습니다.</li></ol><hr><p>[~v0.4]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> breaker = <span class="keyword">typeof</span> <span class="built_in">StopIteration</span> !== <span class="string">'undefined'</span> ? <span class="built_in">StopIteration</span> : <span class="string">'__break__'</span>;</span><br><span class="line"></span><br><span class="line">_.each = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.forEach) &#123;</span><br><span class="line">      obj.forEach(iterator, context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, l=obj.length; i&lt;l; i++) iterator.call(context, obj[i], i, obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> keys = _.keys(obj)</span><br><span class="line">        , l = keys.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;l; i++) iterator.call(context, obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != breaker) <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>v0.4.1</p><ol><li>obj.each를 검사하는 코드가 제거되었습니다.</li></ol><p>v0.4.3</p><ol><li>에러 체크 방식이 변경되었습니다.<br>StopIteration를 체크하는 코드가 있었는데 현재 StopIteration는 Deprecated 되었습니다.</li></ol><p>v0.4.7</p><ol><li>obj Loop시 _.keys function이 추가되었습니다.</li><li>for in -&gt; for 문으로 변경되었습니다. </li></ol><hr><p>[~v0.5]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_.each = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.forEach) &#123;</span><br><span class="line">      obj.forEach(iterator, context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_.isNumber(obj.length)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, l=obj.length; i&lt;l; i++) iterator.call(context, obj[i], i, obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> keys = _.keys(obj), l = keys.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;l; i++) iterator.call(context, obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != breaker) <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>v0.5.1</p><ol><li>obj.length -&gt; <em>.isArray(obj) || </em>.isArguments(obj)로 변경되었습니다.</li></ol><p>v0.5.8</p><ol><li>다시 _.isNUmber(obj.length)로 변경되었습니다.</li></ol><hr><p>[~v0.6.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nativeForEach &amp;&amp; obj.forEach === nativeForEach) &#123;</span><br><span class="line">      obj.forEach(iterator, context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_.isNumber(obj.length)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = obj.length; i &lt; l; i++) iterator.call(context, obj[i], i, obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasOwnProperty.call(obj, key)) iterator.call(context, obj[key], key, obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != breaker) <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>each가 foreach라는 이름도 갖게 되었습니다.</li><li>기본 배열인지 확인하는 비교문이 수정되었습니다.(nativeForEach = ArrayProto.forEach)</li><li>들어오는 obj가 객체인 경우 loop 가 다시 for에서 for in으로 변경되었습니다.<br>내부 loop에서 hasOwnProperty를 사용해서 property확인을 합니다.</li></ol><hr><p>[~v1.1.4]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> each = _.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (nativeForEach &amp;&amp; obj.forEach === nativeForEach) &#123;</span><br><span class="line">    obj.forEach(iterator, context);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_.isNumber(obj.length)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = obj.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (iterator.call(context, obj[i], i, obj) === breaker) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iterator.call(context, obj[key], key, obj) === breaker) <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>try catch문을 제거되었습니다.</li><li>null check를 추가되습니다.</li></ol><hr><p>[~v1.1.7]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> each = _.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (nativeForEach &amp;&amp; obj.forEach === nativeForEach) &#123;</span><br><span class="line">    obj.forEach(iterator, context);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.length === +obj.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = obj.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> obj &amp;&amp; iterator.call(context, obj[i], i, obj) === breaker) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iterator.call(context, obj[key], key, obj) === breaker) <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>_.isNumber(obj.length)가 obj.length === +obj.length으로 변경되었습니다.</li></ol><hr><p>[~v1.3.1]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> each = _.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (nativeForEach &amp;&amp; obj.forEach === nativeForEach) &#123;</span><br><span class="line">    obj.forEach(iterator, context);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.length === +obj.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = obj.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> obj &amp;&amp; iterator.call(context, obj[i], i, obj) === breaker) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_.has(obj, key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iterator.call(context, obj[key], key, obj) === breaker) <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>hasOwnProperty.call(obj, key)이 _.has()로 수정되었습니다.</li></ol><hr><p>[~v1.4.2]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> each = _.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (nativeForEach &amp;&amp; obj.forEach === nativeForEach) &#123;</span><br><span class="line">    obj.forEach(iterator, context);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.length === +obj.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = obj.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (iterator.call(context, obj[i], i, obj) === breaker) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_.has(obj, key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iterator.call(context, obj[key], key, obj) === breaker) <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>obj.length === +obj.length에서 “i in obj”가 제거되습니다.</li></ol><hr><p>[~v1.5.2]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> each = _.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (nativeForEach &amp;&amp; obj.forEach === nativeForEach) &#123;</span><br><span class="line">    obj.forEach(iterator, context);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.length === +obj.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (iterator.call(context, obj[i], i, obj) === breaker) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>obj loop방식도 또 변경되었고, l의 네이밍이 length로 변경되었습니다.</li></ol><hr><p>[~v1.7.0]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_.each = _.forEach = function(obj, iteratee, context) &#123;</span><br><span class="line">  if (obj == null) return obj;</span><br><span class="line">  iteratee = createCallback(iteratee, context);</span><br><span class="line">  var i, length = obj.length;</span><br><span class="line">  if (length === +length) &#123;</span><br><span class="line">    for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[i], i, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    var keys = _.keys(obj);</span><br><span class="line">    for (i = 0, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>interator.call 함수가 전역으로 나누어졌습니다.</li></ol><hr><p>[~v1.8.0]<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = optimizeCb(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> i, length;</span><br><span class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[i], i, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>createCallback -&gt; optimizeCb 으로 function이름이 변경되었습니다. </li><li>null 체크가 삭제되었습니다.</li></ol><hr><blockquote><ol><li>v0.3.1에서 “(Object.prototype.hasOwnProperty.call(obj, key)”를 for문과 같이 쓰이는 구조가 처음보는 익혀둬야 할것 같다.</li><li>점진적으로 여러 예외경우를 추가하면서 try catch 을 제거하는 방식도 괜찮은 방식이인것 같다.</li><li>for문과 for in 문에 반복적으로 교체되고 있다. 장단점을 확실히 아는게 좋을것 같다.</li><li>확실히 최종보전부터 보면 이해가 안되지만 처음버전부터 보면 히스토리를 알게되서 이해가 더 알기 좋다.</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Underscore-의-each&quot;&gt;&lt;a href=&quot;#Underscore-의-each&quot; class=&quot;headerlink&quot; title=&quot;Underscore 의 _.each&quot;&gt;&lt;/a&gt;Underscore 의 _.each&lt;/h3&gt;&lt;p&gt;v1부터 현재까지 코드가 어떻게 변해왔는지 확인해봅니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="underscore" scheme="https://jae-kwang.github.io/blog/categories/js/lib/underscore/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="underscore.js" scheme="https://jae-kwang.github.io/blog/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>Grunt, Gulp, Webpack</title>
    <link href="https://jae-kwang.github.io/blog/2017/03/29/tool-each/"/>
    <id>https://jae-kwang.github.io/blog/2017/03/29/tool-each/</id>
    <published>2017-03-28T23:20:33.000Z</published>
    <updated>2017-03-30T00:18:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2017년에-Grunt와-Gulp를-언급하는-이유"><a href="#2017년에-Grunt와-Gulp를-언급하는-이유" class="headerlink" title="2017년에 Grunt와 Gulp를 언급하는 이유"></a>2017년에 Grunt와 Gulp를 언급하는 이유</h3><p>현재 대세는 단연코 Webpack이라고 할 수 있습니다.<br>하지만 모든 새로운 것들에는 그들이 나오게 된 이유가 있다고 생각됩니다.</p><p>Webpack을 더 잘 사용하기위해서는 이전 Grunt와 Gulp에 대한 이해가 필요하다는 생각이 들어서 간단히 정리해보려고 합니다.</p><a id="more"></a><h3 id="Grunt와-Gulp"><a href="#Grunt와-Gulp" class="headerlink" title="Grunt와 Gulp"></a>Grunt와 Gulp</h3><p>Grunt와 Gulp는 사람의 실수나 반복적인 작업을 줄이기 위한 자동화 툴(task runner)입니다.</p><p>보통 CSS와 Javascript 파일을 concat, minify, compress, uglify를 하는데 많이 사용되죠,<br>즉 사전에 필요한 반복적인 작업들을 간단한 작업만으로 진행할 수 있습니다.</p><p>또한, 이들은 Node.js에서 사용할 수 있으며 여러 Plugin을 활용 할 수 있습니다</p><h3 id="Grunt-vs-Gulp"><a href="#Grunt-vs-Gulp" class="headerlink" title="Grunt vs Gulp"></a>Grunt vs Gulp</h3><p>위에서 처럼 두가지 툴 모두 같은 작업을 수행하지만, 수행하는 방법은 차이가 있습니다</p><h4 id="설정방법"><a href="#설정방법" class="headerlink" title="설정방법"></a>설정방법</h4><p>Grunt는 설정에 기반하여 동작하는 반면, Gulp는 Javascript를 기반으로 동작합니다.</p><p>아래는 Grunt의 설정 예 입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grunt는 JSON 형태의 confing를 구성하는 방식으로 구현됩니다</span></span><br><span class="line">imagemin: &#123;</span><br><span class="line">    jpgs: &#123;</span><br><span class="line">        options: &#123;</span><br><span class="line">        progressive: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        files: [&#123;</span><br><span class="line">            expand: <span class="literal">true</span>,</span><br><span class="line">            cwd: <span class="string">'src/img'</span>,</span><br><span class="line">            src: [<span class="string">'*.jpg'</span>],</span><br><span class="line">            dest: <span class="string">'images/'</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>설정파일 기반의 Grunt와 달리 Gulp는 Javascript (Nodejs) 코딩을 할 줄 아는 사람이면 쉽게 접근할 수 있는 것이 장점인것 같습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gulp는 javascript를 사용합니다.</span></span><br><span class="line">gulp.task(<span class="string">'jpgs'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'src/images/*.jpg'</span>)</span><br><span class="line">    .pipe(imagemin(&#123; <span class="attr">progressive</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'optimized_images'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="속도"><a href="#속도" class="headerlink" title="속도"></a>속도</h4><p>Gulp와 Grunt의 속도의 차이를 이해하기 위해서는 둘의 처리 방식이 다르다는걸 알아야 합니다.</p><p>Gulp는 스트림(Stream)을 기반으로 하는 빌드 시스템 입니다. 스트림을 이용해 데이터를 읽고 출력하며 작업들을 메모리에서 처리합니다. 즉, 요청 후 한번에 결과를 받는 것이 아니라 이벤트 중간중간 전달받아 작업을 하기 때문에 비교적 작업속도가 빠릅니다.</p><blockquote><p>스트림(Stream)이란?<br>  데이터의 입, 출력시 비동기적으로 처리될 수 있는 데이터의 연속된 흐름으로써, Node.js에서는 이 스트림을 읽고 쓸 수 있습니다.</p></blockquote><p>또한 Gulp는 동시에 여러 작업을 처리 할 수 있지만 Grunt는 일반적으로 한 번에 하나의 작업 만 처리합니다.</p><blockquote><p>출처 :</p><ul><li><a href="http://tech.tmw.co.uk/2014/01/speedtesting-gulp-and-grunt/" target="_blank" rel="external">Speedtesting gulp.js and Grunt</a></li><li><a href="http://juhoi.github.io/post/%EB%B2%88%EC%97%AD%5D-introduction-to-node-dot-j-s-streams/" target="_blank" rel="external">Introduction to Node.js Streams</a></li></ul></blockquote><h4 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h4><p>Gulp가 Grunt보다 속다가 빠르다는건 맞지만, 사용의 편의성 또한 무시할 수 있는 부분이 아니기에 무엇이 자신에게 맞는지를 잘 파악해서 사용하는게 좋은것 같습니다.</p><blockquote><p>출처 :</p><ul><li><a href="https://www.keycdn.com/blog/gulp-vs-grunt/" target="_blank" rel="external">Gulp vs Grunt – Comparing Both Automation Tools</a></li><li><a href="https://jaysoo.ca/2014/01/27/gruntjs-vs-gulpjs/" target="_blank" rel="external">Grunt vs Gulp - Beyond the Numbers</a></li><li>etc…</li></ul></blockquote><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Gulp와 Grunt와 같은 자동화 도구덕분에 많은 작업의 양이 줄었는데도 불구하고 Webpack이 나왔습니다. 이런 자동화도구에서 어떤 부분이 불편했던 것이었을까요? 우선 Webpack은 모듈 번들러이고 Gulp와 Grunt는 task runners입니다.</p><p>결론부터 말하자면 Webpack이 이들을 1:1로 대체된다기 보다 이 기능이 포함되어 있고 더 많은 작업을 할 수 있기 때문에 이 도구를 쓰는것입니다. webpack은 Browserify와 같은 의존성 관리 기능까지 포함하고 있으니 “webpack = (Grunt || Gulp) + Browserify” 이게 될텐데 안 쓸 이유가 없을 것입니다. 게다가 속도까지 더 빠르니까요.</p><h4 id="우선-Browserify"><a href="#우선-Browserify" class="headerlink" title="우선 Browserify?"></a>우선 Browserify?</h4><p>Browserify 는 Node.js 기반 javascript code 를 브라우저 환경에서도 실행 가능하도록 해줍니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'./helpers/foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>즉, 브라우저와 Node.js의 코드를 동일하게 사용할 수 있습니다.</p><p>하지만 브라우저에서 작업결과를 봐야하기 때문에 매번 코드를 컴파일이 해야하는데, 코드의 양이 많아지면 하나 수정하는데도 엄청 오래걸릴 수 있다는 얘기가 됩니다.</p><p>참고한 블로그를 보면 webpack을 사용해 watch한 경우 빌드시간이 20초 0.1 ~ 0.3으로 단축되었다는 글을 볼 수 있었습니다.</p><p>실제로 정확히 이해하고 적용하는데는 시간이 걸리겠지만, 좋은 부분이 있다는 건 확실히 이해해야 할것 같습니다.</p><blockquote><p>출처 :</p><ul><li><a href="https://ironhee.com/2015/06/06/webpack-%EB%AA%A8%EB%93%88%ED%99%94%EC%99%80-%EC%86%8D%EB%8F%84%EB%A5%BC-%EB%AA%A8%EB%91%90-%EC%9E%A1%EB%8A%94-%EB%B0%A9%EB%B2%95/" target="_blank" rel="external">Webpack – 모듈화와 속도를 모두 잡는 방법.</a></li><li><a href="https://www.toptal.com/front-end/webpack-browserify-gulp-which-is-better" target="_blank" rel="external">Webpack or Browserify &amp; Gulp: Which Is Better?</a></li><li>etc…</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2017년에-Grunt와-Gulp를-언급하는-이유&quot;&gt;&lt;a href=&quot;#2017년에-Grunt와-Gulp를-언급하는-이유&quot; class=&quot;headerlink&quot; title=&quot;2017년에 Grunt와 Gulp를 언급하는 이유&quot;&gt;&lt;/a&gt;2017년에 Grunt와 Gulp를 언급하는 이유&lt;/h3&gt;&lt;p&gt;현재 대세는 단연코 Webpack이라고 할 수 있습니다.&lt;br&gt;하지만 모든 새로운 것들에는 그들이 나오게 된 이유가 있다고 생각됩니다.&lt;/p&gt;
&lt;p&gt;Webpack을 더 잘 사용하기위해서는 이전 Grunt와 Gulp에 대한 이해가 필요하다는 생각이 들어서 간단히 정리해보려고 합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Tool" scheme="https://jae-kwang.github.io/blog/categories/Tool/"/>
    
    
      <category term="Tool" scheme="https://jae-kwang.github.io/blog/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>filter, map 그리고 reduce</title>
    <link href="https://jae-kwang.github.io/blog/2017/02/15/js-map_reduce/"/>
    <id>https://jae-kwang.github.io/blog/2017/02/15/js-map_reduce/</id>
    <published>2017-02-15T00:46:22.000Z</published>
    <updated>2017-10-11T00:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="데이터-구조-재가공-하기"><a href="#데이터-구조-재가공-하기" class="headerlink" title="데이터 구조 재가공 하기"></a>데이터 구조 재가공 하기</h3><p>작업을 위해 원데이터를 재가공해야할때가 있습니다.<br>원하는 구조를 만들기 위해 filter, map, reduce를 활용할 수 있습니다.</p><a id="more"></a><h2 id="1-filter"><a href="#1-filter" class="headerlink" title="1. filter"></a>1. filter</h2><p>filter는 말 그대로 어떠한 기준으로 데이터를 제한할 수 있습니다.</p><p>아래는 JSON에서 무효한 항목 거르기는 예제입니다.<br>0이 아닌, 숫자 id인 모든 요소의 걸러진 json을 만들기 위해 filter()를 사용합니다.</p><blockquote><p>예제 출처 - <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="external">MDN : Array.prototype.filter()</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ &#123; <span class="attr">id</span>: <span class="number">15</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">-1</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">0</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">12.2</span> &#125;, &#123; &#125;, &#123; <span class="attr">id</span>: <span class="literal">null</span> &#125;, &#123; <span class="attr">id</span>: <span class="literal">NaN</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">'undefined'</span> &#125; ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> invalidEntries = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterByID</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'id'</span> <span class="keyword">in</span> obj &amp;&amp; <span class="keyword">typeof</span>(obj.id) === <span class="string">'number'</span> &amp;&amp; !<span class="built_in">isNaN</span>(obj.id)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    invalidEntries++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrByID = arr.filter(filterByID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과 : [&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;]</span></span><br></pre></td></tr></table></figure><p>위의 예제처럼 filter는 원 데이터를 자신이 원하는 기준을 이용해 재가공 하는데 작업을 수행 할 수 있습니다.</p><h2 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h2><p>map을 활용할 경우 원데이터를 기준으로 데이터를 다른 구조로 변경할 수 있습니다.</p><blockquote><p>예제 출처 - <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">MDN : Array.prototype.map()</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kvArray = [&#123;<span class="attr">key</span>:<span class="number">1</span>, <span class="attr">value</span>:<span class="number">10</span>&#125;, &#123;<span class="attr">key</span>:<span class="number">2</span>, <span class="attr">value</span>:<span class="number">20</span>&#125;, &#123;<span class="attr">key</span>:<span class="number">3</span>, <span class="attr">value</span>: <span class="number">30</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> reformattedArray = kvArray.map(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">   <span class="keyword">var</span> rObj = &#123;&#125;;</span><br><span class="line">   rObj[obj.key] = obj.value;</span><br><span class="line">   <span class="keyword">return</span> rObj;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과 : [&#123;1:10&#125;, &#123;2:20&#125;, &#123;3:30&#125;]</span></span><br></pre></td></tr></table></figure><h2 id="3-reduce"><a href="#3-reduce" class="headerlink" title="3. reduce"></a>3. reduce</h2><p>reduce 메서드는 누산기 역할을 할 수 있으며, 값을 재가공 할 수도 있습니다.</p><p>reduce를 제대로 사용하기위해서는 넣어야할 파라미터들을 잘 알고 있는게 중요합니다.</p><ul><li>previousValue : 이전 마지막 콜백 호출에서 반환된 값 또는 공급된 경우 초기값(initialValue)  </li><li>currentValue : 배열 내 현재 처리되고 있는 요소(element).  </li><li>currentIndex : 배열 내 현재 처리되고 있는 요소의 인덱스.  </li><li>array : reduce에 호출되는 배열.</li></ul><p>우선 reduce활용으로 만든 누산기 예제 입니다.</p><blockquote><p>예제 출처 - <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">MDN : Array.prototype.reduce()</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, currentValue, currentIndex, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과 : 10</span></span><br></pre></td></tr></table></figure><ul><li>initialValue : 초기값을 지정했을 경우</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previousValue, currentValue, currentIndex, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과 : 20</span></span><br></pre></td></tr></table></figure><p>reduce의 좀 더 나은 활용방법은 어떤것이 있을까요?  </p><p>filter를 사용할 경우 원하는 데이터를 어떠한 기준으로 정제할 수 있습니다.<br>다만, 가진 데이터 구조를 변경하지는 못합니다.</p><p>그럼 map은 어떨까요?<br>map을 사용할 경우 데이터 구조를 원하는대로 변경할 수 있지만 그 데이터의 사이즈를 재조정 하지 못합니다.<br>즉, 조건에 맞게 데이터를 넣지 않을 수 있지만 실질적으로 Return 되는 데이터에서 제거되지는 못합니다.</p><p>가장 첫번째 filter의 예제를 활용해 봅시다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ &#123; <span class="attr">id</span>: <span class="number">15</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">-1</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">0</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">12.2</span> &#125;, &#123; &#125;, &#123; <span class="attr">id</span>: <span class="literal">null</span> &#125;, &#123; <span class="attr">id</span>: <span class="literal">NaN</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">'undefined'</span> &#125; ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter를 사용했을 때 number type의 값만 뺐을 경우 아래와 같은 값을 얻을 수 있었습니다.</span></span><br><span class="line"><span class="comment">// [&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;]</span></span><br></pre></td></tr></table></figure><p>map을 사용해 위의 arr에 아래의 label값을 추가하겠습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> label = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>];</span><br><span class="line"></span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">obj, i</span>) </span>&#123;</span><br><span class="line">  obj.label = label[i];</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 결과 </span></span><br><span class="line"><span class="comment">&#123; id: 15, label: 'a'&#125;, &#123; id: -1, label: 'b' &#125;, &#123; id: 0, label: 'c' &#125;, &#123; id: 3, label: 'c' &#125;, &#123; id: 12.2, label: 'd' &#125;,</span></span><br><span class="line"><span class="comment">&#123; name: 'f'&#125;, &#123; id: null, label: 'g' &#125;, &#123; id: NaN, label: 'h' &#125;, &#123; id: 'undefined', label: 'i' &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>그렇다면 map안에 filter에서 사용했던 조건문을 추가해서 작업을 해보죠.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">obj, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span>(obj.id) === <span class="string">'number'</span> &amp;&amp; !<span class="built_in">isNaN</span>(obj.id)) &#123;</span><br><span class="line">    obj.label = label[i];</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="comment">// [Object, Object, Object, Object, Object, undefined, undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure><p>map은 조건문은 값을 제한하여도 원래 사이즈와 동일한 사이즈의 데이터를 리턴해줍니다.</p><p>reduce를 사용해서 데이터를 정제하도록 하겠습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, value, idx</span>) </span>&#123;</span><br><span class="line">  value.label = label[idx];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span>(value.id) === <span class="string">'number'</span> &amp;&amp; !<span class="built_in">isNaN</span>(value.id)) &#123;</span><br><span class="line">    prev.push(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과 : label데이터가 추가가 됨과 동시에 조건문에 맞게 정제된 데이터가 내려옵니다. </span></span><br><span class="line"><span class="comment">// [&#123;id: 15, label: 'a&#125;, &#123;id: -1, label: 'b'&#125;, ... ]</span></span><br></pre></td></tr></table></figure><p>filter와 map의 기능을 reduce에서 동시에 작업할 수 있었습니다.</p><p>하지만 이렇다고 해서 모든 경우 reduce를 쓰는건 옳지 않습니다.<br>적당한 상황에 옳게 쓰기위해 filter, map, reduce를 쓰는 법을 알아야 하겠습니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;데이터-구조-재가공-하기&quot;&gt;&lt;a href=&quot;#데이터-구조-재가공-하기&quot; class=&quot;headerlink&quot; title=&quot;데이터 구조 재가공 하기&quot;&gt;&lt;/a&gt;데이터 구조 재가공 하기&lt;/h3&gt;&lt;p&gt;작업을 위해 원데이터를 재가공해야할때가 있습니다.&lt;br&gt;원하는 구조를 만들기 위해 filter, map, reduce를 활용할 수 있습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="method" scheme="https://jae-kwang.github.io/blog/categories/js/method/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>여러줄에서 말줄임표 사용하기</title>
    <link href="https://jae-kwang.github.io/blog/2017/01/30/css-multiline_ellipsis/"/>
    <id>https://jae-kwang.github.io/blog/2017/01/30/css-multiline_ellipsis/</id>
    <published>2017-01-30T05:32:00.000Z</published>
    <updated>2017-10-11T00:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="멀티라인에서의-말줄임은-단일줄과-다릅니다"><a href="#멀티라인에서의-말줄임은-단일줄과-다릅니다" class="headerlink" title="멀티라인에서의 말줄임은 단일줄과 다릅니다."></a>멀티라인에서의 말줄임은 단일줄과 다릅니다.</h3><p>기존 말줄임은 간단히 ‘text-overflow: ellipsis’ 속성을 사용하여 적용 할 수 있습니다.<br>말줄임 기능은 여러줄에 있을 경우 더욱 필요한 경우가 더 많습니다.<br>하지만 우리가 아는 ellipsis로는 구현할 수 없습니다.</p><a id="more"></a><p>웹킷엔진을 사용하는 브라우저에서는 -webkit-line-clamp 프로퍼티를 활용하여 여러줄의 문단도 CSS를 통해 말줄임 처리를 할 수 있습니다.</p><p><a href="http://caniuse.com/#search=line-clamp" target="_blank" rel="external">지원하는 브라우저 확인하기</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>; <span class="comment">/* 블록을 임의의 배치 순서로 변경할 수 있게 해줌 */</span></span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 3; <span class="comment">/* 라인수 */</span></span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>; <span class="comment">/* 박스의 흐름의 방향을 지정 */</span></span><br></pre></td></tr></table></figure><h3 id="webkit-line-clamp-미지원-브라우저-지원"><a href="#webkit-line-clamp-미지원-브라우저-지원" class="headerlink" title="-webkit-line-clamp 미지원 브라우저 지원"></a>-webkit-line-clamp 미지원 브라우저 지원</h3><p>-webkit-line-clamp를 지원하지 않는 브라우저에서는 아래와 같이 사용할 수 있습니다.</p><p>height = line-height * -webkit-line-clamp 으로 설정해주시면 됩니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">block</span>; <span class="comment">/* Fallback for non-webkit */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 3; </span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br><span class="line"><span class="selector-tag">line-height</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 60<span class="selector-tag">px</span>; <span class="comment">/* Fallback for non-webkit */</span></span><br></pre></td></tr></table></figure><p>하지만, 위의 방식으로 하면 텍스트를 원하는 만큼 줄이는건 가능하지만 여전히 ‘…’ 를 사용하는 말줄임이 노출되지는 않습니다</p><h3 id="firefox에서-‘…’-표현하기"><a href="#firefox에서-‘…’-표현하기" class="headerlink" title="firefox에서 ‘…’ 표현하기"></a>firefox에서 ‘…’ 표현하기</h3><p>firefox는 line-clamp을 지원하지 않는 브라우저중 하나입니다.<br>이때는 css hack을 활용해 ‘…’를 나타낼 수 있습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">document</span> url-prefix() &#123;</span><br><span class="line">  <span class="selector-class">.DescriptionExcerpt</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.DescriptionExcerpt</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'\2026'</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">3rem</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">3rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.DescriptionExcerpt</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@-moz-document url-prefix는 Gecko (Mozilla Firefox) 만 타겟팅하는 데 사용되는 CSS 해킹입니다.<br>다른 모든 브라우저는 스타일을 무시합니다.</p><p>즉, 다른 미지원 브라우저들도 hack을 활용하여 ‘…’을 나타낼 수 있습니다.<br><span class="highlight-text danger">하지만, 이렇게 되면 각 브라우저마다 다른 코드들을 생성으로 코드가 길어질 수 있습니다.</span>  <br><br>그렇기때문에 모든 브라우저를 지원하는게 단순히 일정 브라우저에서 지원하는것보다 중요하다면,<br><span class="highlight-text primary">line-clamp를 사용하는것 대신에 공통으로 쓸 수 있는 코드를 사용하는것도 좋은방법일거라 생각됩니다.</span></p><p>참고자료 :</p><ol><li><a href="http://stackoverflow.com/questions/3123063/what-does-moz-document-url-prefix-do" target="_blank" rel="external">What does @-moz-document url-prefix() do?</a></li><li><a href="http://revelry.co/multi-line-ellipsis-using-pure-css/" target="_blank" rel="external">Multi-line Ellipsis using pure CSS as a work around.</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;멀티라인에서의-말줄임은-단일줄과-다릅니다&quot;&gt;&lt;a href=&quot;#멀티라인에서의-말줄임은-단일줄과-다릅니다&quot; class=&quot;headerlink&quot; title=&quot;멀티라인에서의 말줄임은 단일줄과 다릅니다.&quot;&gt;&lt;/a&gt;멀티라인에서의 말줄임은 단일줄과 다릅니다.&lt;/h3&gt;&lt;p&gt;기존 말줄임은 간단히 ‘text-overflow: ellipsis’ 속성을 사용하여 적용 할 수 있습니다.&lt;br&gt;말줄임 기능은 여러줄에 있을 경우 더욱 필요한 경우가 더 많습니다.&lt;br&gt;하지만 우리가 아는 ellipsis로는 구현할 수 없습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="https://jae-kwang.github.io/blog/categories/css/"/>
    
    
      <category term="css" scheme="https://jae-kwang.github.io/blog/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>반복문에서 break, continue 사용하기</title>
    <link href="https://jae-kwang.github.io/blog/2017/01/08/js-forEach/"/>
    <id>https://jae-kwang.github.io/blog/2017/01/08/js-forEach/</id>
    <published>2017-01-08T05:35:33.000Z</published>
    <updated>2017-10-11T00:31:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS에서-break와-continue사용하기"><a href="#JS에서-break와-continue사용하기" class="headerlink" title="JS에서 break와 continue사용하기"></a>JS에서 break와 continue사용하기</h3><p>자바스크립트에서 제공하는 반복문으로 break와 continue를 사용해보자.</p><a id="more"></a><p>보통 프로그래밍 언어에서 break와 continue을 사용할때 아래의 경우처럼 문을 사용합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == j) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forEach에서는 어떻게 사용할까요?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="number">2</span>) <span class="keyword">continue</span>; <span class="comment">// or break;</span></span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><span class="highlight-text danger">forEach에서는 continue와 break를 사용할 수 없습니다.</span><p>대신 .some()을 사용 할 수 있습니다.</p><p>.some()은 컬렉션의 요소 중 최소 1개라도 조건을 만족시키는지 검사하는 메서드 입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].some(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>return true; 가 break 라면,<br>return false; 는 continue 입니다.</p><blockquote><p>출처 - Outsider님 Blog : <a href="https://blog.outsider.ne.kr/847" target="_blank" rel="external">forEach에 break문 대신 some 사용하기</a></p></blockquote><p>jQuery의 $.each에서는 어떨까요?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.each([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>return true; 가 continue 이며,<br>return false; 는 break 입니다.</p><p>some과 다른이유는 some이 break와 continue를 위해 return true와 false를 하는 용도로 만들어진게 아니기 때문입니다.</p><p>간단한 경우지만 막상 쓰려면 기억이 잘 나지 않는경우가 있는데 알고 있으면 좋은것 같습니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JS에서-break와-continue사용하기&quot;&gt;&lt;a href=&quot;#JS에서-break와-continue사용하기&quot; class=&quot;headerlink&quot; title=&quot;JS에서 break와 continue사용하기&quot;&gt;&lt;/a&gt;JS에서 break와 continue사용하기&lt;/h3&gt;&lt;p&gt;자바스크립트에서 제공하는 반복문으로 break와 continue를 사용해보자.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="method" scheme="https://jae-kwang.github.io/blog/categories/js/method/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>테이블 패턴을 활용한 레이아웃</title>
    <link href="https://jae-kwang.github.io/blog/2016/12/08/css-table_layout/"/>
    <id>https://jae-kwang.github.io/blog/2016/12/08/css-table_layout/</id>
    <published>2016-12-07T23:57:02.000Z</published>
    <updated>2017-10-11T00:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="어떤-방법으로-레이아웃을-만드시나요"><a href="#어떤-방법으로-레이아웃을-만드시나요" class="headerlink" title="어떤 방법으로 레이아웃을 만드시나요?"></a>어떤 방법으로 레이아웃을 만드시나요?</h3><p>레이아웃을 고려할때 여러 방법을 생각을 하게 됩니다.<br>많은 방법중에 테이블패턴을 활용한 레이아웃은 생각보다 편합니다.</p><a id="more"></a><p>이런저런 레이아웃을 만들면서 새로운 방법들을 점점 배워가는것 같습니다.</p><p>처음 웹을 배울때는 <code>&lt;div&gt;</code>로 모든 컨텐츠를 만들때도 있었고,<br><a href="http://getbootstrap.com/" target="_blank" rel="external">Bootstrap</a>을 알고부터는 class=”col-xs-*”로 도배를 한 적도 있었습니다.<br>(물론 반응형을 구현할때는 요긴하고 사용합니다.)</p><p>당시에 저는 테이블 패턴을 이용한 레이아웃은 옛날 옛적의 방식이라고 생각했었습니다.<br>그러나 <code>&lt;table&gt;</code> 태그를 사용하는것과 테이블 패턴을 사용하는것은 차이가 있다는 것을 알게되었습니다.</p><p>처음 테이블 패턴을 접한건 <span class="highlight-text primary">"수직 중앙정렬" </span>이 필요해서 였습니다.<br>단순 중앙정렬은 text-align:”center”나 “margin: 0 auto”을 활용해서 쉽게 구현이 가능합니다.</p><p>하지만 “수직 중앙정렬”은 뭔가 입맞에 딱 맞는게 없었습니다.<br>늘 margin이나 padding 그것도 안되면 absolute를 사용해 어떻게 사용해서 하는 방식이 너무 구렸(?)습니다.</p><p>아래는 간단히 그 방법을 설명하는 좋은 링크가 있어서 참조 합니다.</p><blockquote><p><a href="https://webdesign.tutsplus.com/ko/tutorials/the-holy-grail-of-css-centering--cms-22114" target="_blank" rel="external">최고의 CSS 중앙정렬 기법</a></p></blockquote><p>이러한 방식을 레이아웃에도 적용할수 있을 뿐만 아니라, 상위정렬이나 하위정렬을 만들어 놓으면 편리하게 사용할 수 있습니다.</p><p>위의 링크처럼 .inner를 지정해서 사용해도 좋지만 마크업으로 설계를 잘한다면 굳이 하위 클래스를 만들지 않고 아래와 같이 사용할 수도 있습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.table-layout</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.table-layout-top</span> &gt; * &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.table-layout-middle</span> &gt; * &#123;</span><br><span class="line">   <span class="attribute">display</span>: table-cell;</span><br><span class="line">   <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.table-layout-bottom</span> &gt; * &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>물론 이 방법도 단점이 있습니다.<br>레이아웃사이에 gutter가 당연히 존재할텐데 이때 별도의 마크업을 추가해야 하는 점이 그렇습니다.</p><p>다만 이런 방식으로 레이아웃을 구현할 수 있다는 점을 알아두면 좋을것 같습니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;어떤-방법으로-레이아웃을-만드시나요&quot;&gt;&lt;a href=&quot;#어떤-방법으로-레이아웃을-만드시나요&quot; class=&quot;headerlink&quot; title=&quot;어떤 방법으로 레이아웃을 만드시나요?&quot;&gt;&lt;/a&gt;어떤 방법으로 레이아웃을 만드시나요?&lt;/h3&gt;&lt;p&gt;레이아웃을 고려할때 여러 방법을 생각을 하게 됩니다.&lt;br&gt;많은 방법중에 테이블패턴을 활용한 레이아웃은 생각보다 편합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="https://jae-kwang.github.io/blog/categories/css/"/>
    
    
      <category term="css" scheme="https://jae-kwang.github.io/blog/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS 말줄임표 사용시 기억할 점</title>
    <link href="https://jae-kwang.github.io/blog/2016/11/15/css-ellipsis/"/>
    <id>https://jae-kwang.github.io/blog/2016/11/15/css-ellipsis/</id>
    <published>2016-11-15T09:49:54.000Z</published>
    <updated>2017-10-11T00:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSS-말-줄임표를-사용하려면"><a href="#CSS-말-줄임표를-사용하려면" class="headerlink" title="CSS 말 줄임표를 사용하려면 ?"></a>CSS 말 줄임표를 사용하려면 ?</h3><p>CSS를 사용시 단락에 ‘말 줄임표’를 사용할 경우가 있는데,<br>이때 ‘text-overflow: ellipsis’ 속성을 사용하여 적용 할 수 있습니다.</p><a id="more"></a><p>사용하려면 다른 속성들이 같이 사용되어야 하는데 거의 공식과 같으니 알아두면 좋습니다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ellipsis</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS-말줄임표와-사용-가능한-마크업"><a href="#CSS-말줄임표와-사용-가능한-마크업" class="headerlink" title="CSS 말줄임표와 사용 가능한 마크업"></a>CSS 말줄임표와 사용 가능한 마크업</h3><p>위의 방식처럼 잘 사용하다가 갑자기 적용이 안되면서 삽질을 한차례 했습니다.<br>해당 속성을 쓰는데 있어 기초가 되는 사실을 잊었기 때문입니다.</p><p>위의 코드를 보면 ‘ellipsis’를 쓰기 위해서는 ‘width’를 지정 해주었습니다.<br>‘width’를 지정해야 한다는 의미는 ‘width’가 <span class="highlight-text danger">지정 가능</span>해야 한다는 부분입니다.</p><p>평소 저는 ‘ellipsis’를 <code>&lt;p&gt;</code>에 주로 사용했습니다.<br>그러나 이번에는 최근에 <code>&lt;b&gt;</code>와 <code>&lt;strong&gt;</code>의 차이를 알게되면서 “마크업 사용시 목적에 맞게 사용하자” 라는 생각을 갖고, <code>&lt;b&gt;</code>에 해당 css를 적용했습니다.</p><p>하지만, <code>&lt;b&gt;</code>는 기본적으로 <code>&lt;span&gt;</code>과 같은 ‘display: inline’속성을 가지고 있기 때문에 적용이 불가능했고,<br><code>&lt;b&gt;</code>의 ‘display: inline-block’으로 바꾸고 나서야 정상 작동하는걸 확인할 수 있었습니다.</p><p>간단한 CSS라도 충분히 이해하고 사용해야 할것 같습니다. </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS-말-줄임표를-사용하려면&quot;&gt;&lt;a href=&quot;#CSS-말-줄임표를-사용하려면&quot; class=&quot;headerlink&quot; title=&quot;CSS 말 줄임표를 사용하려면 ?&quot;&gt;&lt;/a&gt;CSS 말 줄임표를 사용하려면 ?&lt;/h3&gt;&lt;p&gt;CSS를 사용시 단락에 ‘말 줄임표’를 사용할 경우가 있는데,&lt;br&gt;이때 ‘text-overflow: ellipsis’ 속성을 사용하여 적용 할 수 있습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="https://jae-kwang.github.io/blog/categories/css/"/>
    
    
      <category term="css" scheme="https://jae-kwang.github.io/blog/tags/css/"/>
    
  </entry>
  
</feed>
